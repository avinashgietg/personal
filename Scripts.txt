##########To run a .sh script from dcli##########################
dcli -g ~/dbs_group -l root "sh /tmp/chk_statefulalert.sh"


27261730

##########To connect to an ILOM console ##########################
[root@myclusterdb01 dbserver_patch_5.170131]# ssh root@myclustercel01-ilom
 Password:
 Oracle(R) Integrated Lights Out Manager
 Version 3.1.2.20.c r86871
 Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
 > start /sp/console
 Are you sure you want to start /SP/console (y/n)? y
 Serial console started. To stop, type ESC (


##########To stop the clusterware##########################
[root@myclusterdb01 ~]#crsctl stop cluster -all
[root@myclusterdb01 ~]#crsctl stop crs
[root@myclusterdb01 ~]#crsctl check crs

##########To stop the cells##########################
Run the following command in each cell:
[root@myclustercel01 ~]# cellcli -e 'alter cell shutdown services all'
Or,
Use the dcli command to launch it on all the cells:
dcli -g ~/cell_group -l root "cellcli -e alter cell shutdown services all"

##########To check the Version Of Each IB Switch##########################
[root@myclusterdb01 ~]# dcli -g ~/ib_group -l root version | grep "version"
myclustersw-ib2: SUN DCS 36p version: 2.1.3-4
myclustersw-ib3: SUN DCS 36p version: 2.1.3-4
[root@myclusterdb01 ~]#

##########To check the Version Of Each Cell##########################
dcli -g ~/cell_group -l root imageinfo -ver


##########To check the Version Of Each DBNode##########################
dcli -g ~/dbs_group -l root imageinfo -ver

##########OJVM Reinstall Steps#######################
Doc ID 2314363.1

Doc ID 888828.1















#################### Show All Product Information #######################

select * from product_component_version;


################# General check DB Availability ################

select name,open_mode,database_role from gv$database;

select instance_name,host_name,status,logins,to_char(startup_time,'YYYY-MON-DD HH24:MI:SS') from gv$instance;

select object_type,count(1) from dba_objects where owner='ODSSHIVA' group by object_type order by object_type;

Check history - echo $HISTFILE , and then cat the output-file
    

############################## Checking O.S related stuffs ###################################

O.S log - var/adm/syslog/syslog.log (hp -ux)

Systeminfo | Find "Up Time"
Or
net statistics server

psrinfo -v|grep "Status of processor"|wc -l

Put current dir on stack so you can popd back to it : pushd .

Print in 9 columns to width of terminal             : ls /usr/bin | pr -T9 -W$COLUMNS
1
Encrypt file : gpg -c file
Decrypt file : gpg file.gpg

Extract info from locale database : echo "I live in `locale territory`"

To check difference between two files :
diff /etc/fstab.mybackup /etc/fstab

That should output only the single line you added, with a ">" sign in front of it.

Increasing swap space in linux :
------------------------------- 
# dd if=/dev/zero of=/myswapfile bs=1M count=1024
1024+0 records in
1024+0 records out

# ls -l /myswapfile
-rw-r--r--    1 root     root     1073741824 Aug 14 23:47 /myswapfile
Change the permission of the swap file so that only root can access it.

# chmod 600 /myswapfile
Make this file as a swap file using mkswap command.

# mkswap /myswapfile
Setting up swapspace version 1, size = 1073737 kB
Enable the newly created swapfile.

# swapon /myswapfile
To make this swap file available as a swap area even after the reboot, add the following line to the /etc/fstab file.

# vi /etc/fstab and add the below entry :
/myswapfile               swap                    swap    defaults        0 0
Verify whether the newly created swap area is available for your use.

# swapon -s
Filename                        Type            Size    Used    Priority
/dev/sda2                       partition       4192956 0       -1
/myswapfile                file            1048568 0       -2

# free -k
             total       used       free     shared    buffers     cached
Mem:       3082356    3022364      59992          0      52056    2646472
-/+ buffers/cache:     323836    2758520
Swap:      5241524          0    5241524

Note: In the output of swapon -s command, the Type column will say “file” if the swap space is created from a swap file.

If you don’t want to reboot to verify whether the system takes all the swap space mentioned in the /etc/fstab, you can do the following, which will disable and 
enable all the swap partition mentioned in the /etc/fstab

# swapoff -a

# swapon -a



Networking:
----------
Show status of ethernet interface eth0             	: ethtool eth0 (As root)
Manually set ethernet interface speed         		: ethtool --change eth0 autoneg off speed 100 duplex full (As root)
Show link status of wireless interface wlan0  		: iw dev wlan0 link
Manually set wireless interface speed         		: iw dev wlan0 set bitrates legacy-2.4 1
List wireless networks in range               		: iw dev wlan0 scan
List network interfaces                       		: ip link show
Rename interface eth0 to wan                  		: ip link set dev eth0 name wan
Bring interface eth0 up (or down)             		: ip link set dev eth0 up
List addresses for interfaces                 		: ip addr show
Add (or del) ip and mask (255.255.255.0)      		: ip addr add 1.2.3.4/24 brd + dev eth0
List routing table                            		: ip route show
Set default gateway to 1.2.3.254              		: ip route add default via 1.2.3.254
List internet services on a system            		: ss -tupl
List active connections to/from system        		: ss -tup
Lookup DNS ip address for name or vice versa            : host pixelbeat.org
Lookup local ip address (equivalent to host `hostname`) : hostname -i
Lookup whois info for hostname or ip address            : whois pixelbeat.org

Calender:
--------

Starts Stop-watch						: time cat  ; Ctrl-d to stop
Display a calendar             					: cal 3
Display a calendar for a particular month year			: cal 12 2013
What date is it this friday					: date -d fri
What day does xmas fall on, this year				: date --date='25 Dec' +%A
What time is it on west coast of US (use tzselect to find TZ)	: TZ='America/Los_Angeles' date
What's the local time for 9AM next Friday on west coast US      : date --date='TZ="America/Los_Angeles" 09:00 next Fri'


Disk-Space:
----------
Sort paths by easy to interpret disk usage			: du -hs /home/* | sort -k1,1h
Show free inodes on mounted filesystems				: df -i
Show disks partitions sizes and types (run as root)		: fdisk -l
List all packages by installed size (Bytes) on rpm distros	: rpm -q -a --qf '%10{SIZE}\t%{NAME}\n' | sort -k1,1n
List all packages by installed size (KBytes) on deb distros	: dpkg-query -W -f='${Installed-Size;10}\t${Package}\n' | sort -k1,1n
truncate data of file or create an empty file			: > file


Check AIX Info's:
----------------
ls -al $ORACLE_HOME/bin/oracle >> /tmp/support.txt
oslevel -s
whoami >> /tmp/support.txt
ulimit -a >> /tmp/support.txt
svmon -O unit=MB >> /tmp/support.txt
/usr/sbin/lsps -a >> /tmp/support.txt
/usr/sbin/lsattr -HE -l sys0 -a realmem >> /tmp/support.txt
ipcs -m >> /tmp/support.txt
opatch lsinventory -detail


Check LINUX Info's:
------------------
arch
cat /etc/issue
whoami
ulimit -a
df -h /dev/shm
ipcs -ma
cat /etc/sysctl.conf
cat /proc/meminfo
cat /proc/swaps
cat /proc/vmstat
opatch lsinventory -detail
rpm -qa|grep oracle ##To check rpm installed##

To check if space can be added from unix end into the F.S : vgdisplay vgdata 

To check if space is avialable on VG 
-------------------------------------------------------
$ /usr/sbin/vgdisplay  vgdata1

Then FREE PE * PE SIZE = ___ MB

Check RAM Info.
---------------
DEC-UNIX uerf -r 300 | grep -i mem 
Solaris -  prtconf|grep -i mem 
AIX - lsdev -C|grep mem 
Linux - free 
HP/UX - swapinfo -tm 


#########GUNZIP,TAR & BZIP2#######################

For Files:
---------

-sh-4.1$  tar -zcvf avi.dmp.tar avi.dmp ####To make .dmp.tar from .dmp##########

-sh-4.1$  tar -zcvf avi.dmp.gz.tar avi.dmp ####To make .dmp.gz.tar from .dmp##########

-sh-4.1$  tar -zxvf avi.dmp.gz.tar ####To make .dmp from .dmp.gz.tar##########

-sh-4.1$ tar cvfj avi.dmp.tar.bz2 avi.dmp ####To make .dmp.tar.bz2 from .dmp##########

-sh-4.1$ tar xvfj avi.dmp.tar.bz2 ####To make .dmp from .dmp.tar.bz2##########

-sh-4.1$ gzip avi.dmp

-sh-4.1$ gunzip avi.dmp.gz (or) gzip -d avi.dmp.gz (or) zcat avi.dmp.gz

-sh-4.1$ bzip2 avi.dmp

-sh-4.1$ bzip2 -d  avi.dmp.bz2


For Directory's:
---------------

To copy directories   :    cp -r cdmp_20*.* /oradump/trace
To remove directories :    rm -rf cdmp_20*

-sh-4.1$  tar -c DUMP | bzip2 > DUMP.tar.bz2 ###To make compressed archive of directory 'DUMP' - Very Efficient ###################

-sh-4.1$ bzip2 -dc DUMP.tar.bz2 | tar -x     ###To extract archive (use gzip instead of bzip2 for tar.gz files) ###################

tar -c dir/ | gzip | gpg -c | ssh user@remote 'dd of=dir.tar.gz.gpg' ####Make encrypted archive of dir/ on remote machine#########

find dir/ -name '*.txt' | tar -c --files-from=- | bzip2 > dir_txt.tar.bz2 ####Make archive of subset of dir/ and below#########

find dir/ -name '*.txt' | xargs cp -a --target-directory=dir_txt/ --parents ####Make copy of subset of dir/ and below#########

( tar -c /dir/to/copy ) | ( cd /where/to/ && tar -x -p ) ####Copy (with permissions) copy/ dir to /where/to/ dir#########

( cd /dir/to/copy && tar -c . ) | ( cd /where/to/ && tar -x -p ) ####Copy (with permissions) contents of copy/ dir to /where/to/#########

( tar -c /dir/to/copy ) | ssh -C user@remote 'cd /where/to/ && tar -x -p' ####Copy (with permissions) copy/ dir to remote:/where/to/ dir#########

dd bs=1M if=/dev/sda | gzip | ssh user@remote 'dd of=sda.gz' ####Backup harddisk to remote machine#########



############################## O.S commands - Copy,Move###################################

find ./ -name "*.aud" -exec mv {} /oradump/trace/ \; -print



###################################### Unix find & Removing commands##################################################

find / -name "*listener*" > test.txt
find /opt/oracle -xdev -type f -size +5000000c -exec ls -lrt {} \; | sort -nk 5
find location/*.trc -mtime +30 -exec rm {} \;
find . -xdev -size +100000 -exec ls -lh {} \;
find /opt/oracle/ -size +1G -exec du -h {} \;
find /home -xdev -type f -size +5000000c -exec ls -ld {} \; | sort -nk 5
find /u01/app/oracle/admin/p233/bdump -name "*.trc" -mtime +4 -exec rm -rf {} \;
find -name '*.[ch]' | xargs grep -E 'expr' ###Search 'expr' in this dir and below###
find -type f ! -perm -444 ###Find files not readable by all###
find -type d ! -perm -111 ###Find dirs not accessible by all ###






Listing out directories  iftn unix :  ls -l | grep "^d"
				    du -sh * | sort -nr
				    du -sk * | sort +0nr
				    du -ms *



Vi command : find and replace globally:-

:%s/text1/text2/g[RETURN]

:1,$ s/<find string>/<replace string>/g

du -H --max-depth=1 /dev


simple find command : find $ORACLE_HOME -size +1073741824c   

ls -ltr | head -20 | awk '{print "cat /dev/null >" $9}' > /home/oracle/rm.sh

clearing the listener logs:
cat listener.log | gzip -9 >listner.log.20100308.gz ## backing up and zipping the content ##
cat /dev/null  >listener.log ## nullifying the content ##

cat alert_FP.log | gzip -9 > alert_FP.log.20110207.gz
cat /dev/null  > listener_fp.log

cat listener_fp.log | gzip -9 > /disk20_7/oradata/bkp_disk01/listener_fp.log.20110207.gz

/disk20_7/oradata/bkp_disk01/listener_fp.log.20110207.gz

  /y/prod/oracle/pdbk0/bdump
cat alert_pdbk0.log > gzip -9 > /arch_dump/alert_pdbk0.log.20091006.gz


##############################O.S Commands - Compress & De-compress##########################################

Compressing cmds : gzip 'filename' (To Compress)
                   gzip -d 'filename' or gunzip 'filename' or zcat 'filename' (TO De-compress)
to get the statement:-
ls -lrt  HRTarch1_24*.dbf | awk '{ print "gzip " $9}'


ls -alrt arch1_69*.dbf.gz |awk '{ print "  rm -f " $9}' > remove.lis

ls -alrt arch1_700*.dbf.gz |awk '{ print "  rm -f " $9}' > remove1.lis

ls -alrt arch1_701*.dbf.gz |awk '{ print "  rm -f " $9}' |sh

to get the shell working:-

ls -lrt  HRTarch1_24*.dbf | awk '{ print "gzip " $9}' | sh


for I in `ls p24436624_121020_Linux-x86-64*f10.zip`
do
unzip $I
done



############## 

Here are the top 20 cpu usage process : 

lclvap222:/u/jimsun$>ps aux | head -1; ps aux | sort -rn +2 | head -20

get a file from the server use the following command :
 	scp account@server_name:/target_folder/file_name target_name

e.g. saehop01.espoo /work $ scp rootdba@eshrdp01-m:/tmp/hs_err_pid2569.log .
rootdba@eshrdp01-m's password:
hs_err_pid2569.log                            100% 5051   340.0KB/s   00:00
(note the dot at the end) 

4.	put a file to the server use the following command :
 	scp file_name account@server_name:/target_folder/name	
e.g. saehop01.espoo /work $ scp hs_err_pid2569.log rootdba@sainfd01-m:/tmp/.
rootdba@sainfd01-m's password:
hs_err_pid2569.log                            100% 5051    14.1MB/s   00:00

#############################################################


# Type the following command:
Systeminfo | Find "Up Time"

 @?/rdbms/admin/addmrpt.sql -- addm report

 @?/rdbms/admin/awrrpt.sql - awr 

=====================================================================
 

############Script for All DB shutdown and startup on a server##########################

for db in `cat /etc/oratab|grep -v '^$'|grep -v '#'|grep -v '*'|grep -v '+ASM1'|grep -v '+ASM2'|awk -F\: ' { print $1 }'`
do
. oraenv<<EOF>/dev/null
$db
EOF
sqlplus -s "/as sysdba"<<EOF
shu immediate;
exit
EOF
echo "DB stopped $db"
done


for db in `cat /etc/oratab|grep -v '^$'|grep -v '#'|grep -v '*'|grep -v '+ASM1'|grep -v '+ASM2'|awk -F\: ' { print $1 }'`
do
. oraenv<<EOF>/dev/null
$db
EOF
sqlplus -s "/as sysdba"<<EOF
startup;
exit
EOF
echo "DB started $db"
done


i=`cat dblist`
for x in $i
do
export ORACLE_SID=$x
ORAENV_ASK=NO
. oraenv >> /dev/null
dbname=`$ORACLE_HOME/bin/sqlplus -s "as sysdba" << _eof
set pagesize 0 feedback off verify off heading off echo off
select name from v\\$database;
exit;
_eof`
echo "DB NAME : $x" >> dbname.log
done



#!bin/sh
host=`hostname -f`
dat=`$date "+%d%m%y"`
username="dbmsowner"
record=0
while read l ; do
record = `expr $record + 1`
echo $record
if [ "$record" == 1 ]; then
psql $l $username << EOF
COPY(select '$host' as HOST,'$x' as DBName, * from pg_user) TO  '/tmp/user_reports_$host_$dat.csv' DELIMITER ',' CSV HEADER;
COPY(select '$host' as HOST,'$x' as DBName, * from pg_roles) TO '/tmp/roles_reports_$host_$dat.csv' DELIMITER ',' CSV HEADER;
COPY(select '$host' as HOST,'$x' as DBName, * from information_schema.table_privilege) TO '/tmp/privs_reports_$host_$dat.csv' DELIMITER ',' CSV HEADER;
else
psql $l $username << EOF
COPY(select '$host' as HOST,'$x' as DBName, * from pg_user) TO PROGRAM 'cat >> /tmp/user_reports_$host_$dat.csv' DELIMITER ',' CSV;
COPY(select '$host' as HOST,'$x' as DBName, * from pg_roles) TO PROGRAM 'cat >> /tmp/roles_reports_$host_$dat.csv' DELIMITER ',' CSV;
COPY(select '$host' as HOST,'$x' as DBName, * from information_schema.table_privilege) TO PROGRAM 'cat >> /tmp/privs_reports_$host_$dat.csv' DELIMITER ',' CSV;
EOF
fi

done < dblist.txt



#################################### Script to sync files between 2 directories across servers ####################################
#!/bin/bash
# RSYNC SCRIPT TO SYNC TWO SERVER'S SPECIFIC DIRECTORIES
SOURCE_PATH='/db/oracle/'
SOURCE_SERVER='192.168.10.20'  #Added for reference
DESTINATION_PATH='/db/oracle-bck/'
DESTINATION_HOST='192.168.10.25'
DESTINATION_USER='root'
LOGFILE='rsync_oralce.log'
echo $'\n\n' >> $LOGFILE
rsync -av --rsh=ssh $SOURCE_PATH $DESTINATION_USER@$DESTINATION_HOST:$DESTINATION_PATH 2>&1 >> $LOGFILE
echo "Sync Completed at:`/bin/date`" >> $LOGFILE 


#!/bin/bash
# COPY SCRIPT TO SYNC TWO SERVER'S SPECIFIC DIRECTORIES
SOURCE_PATH='/home/oracle/avinash/.'
SOURCE_SERVER='10.118.38.11'  #Added for reference
DESTINATION_PATH='/home/oracle/avinash/.'
DESTINATION_HOST='10.118.38.12'
DESTINATION_USER='oracle'
LOGFILE='copy_files.log'
echo $'\n\n' >> $LOGFILE
scp -r $SOURCE_PATH $DESTINATION_USER@$DESTINATION_HOST:$DESTINATION_PATH 2>&1 >> $LOGFILE
echo "Copy Completed at:`/bin/date`" >> $LOGFILE




#!/bin/bash
# COPY SCRIPT TO SYNC TWO SERVER'S SPECIFIC DIRECTORIES
read -p $'\e[31mEnter the Source Host\e[0m:' SRC_HOST
read -p $'\e[32mEnter the Destination Host\e[0m:' DTN_HOST

read -p $'\e[31mEnter the Source Path\e[0m:' SRC_PATH
read -p $'\e[32mEnter the Destination Path\e[0m:' DTN_PATH
DESTINATION_USER='oracle'
LOGFILE='copy_files.log'
echo $'\n\n' >> $LOGFILE
scp -r $SRC_PATH $DESTINATION_USER@$DTN_HOST:$DTN_PATH 2>&1 >> $LOGFILE
echo "Copy Completed at:`/bin/date`" >> $LOGFILE





################Oracle 12c Commands##################################

To check if the DB is a C-DB:
select name,cdb,con_id from v$database;

To check instance status:
select instance_name,status,con_id from v$instance;

List the services automatically created for each container:
select name,con_id from v$services;

To check P-DB infos:
select con_id,name,open_mode from v$pdbs;

To check which containe you are connected to:
show con_name;

To list out the temp files of the CDB:
select file_name,tablespace_name,file_id from cdb_temp_files;


List all common users of the CDB:
select distinct username from cdb_users where common='YES';

List all local users of the CDB:
select distinct username,con_id from cdb_users where common='NO';

List all roles of the CDB:
select role,common,con_id from cdb_roles;

To check if privileges are neither common nor local by nature:
DESC sys.system_privilege_map
DESC sys.table_privilege_map

Check CDB level privileges:

DESC cdb_sys_privs
DESC cdb_tab_privs
DESC cdb_role_privs









##########ARCHIVE###################

select max(sequence#),thread# from v$log_history group by thread#;

select error from v$archive_dest;

Select dest_id, status, type, ARCHIVED_THREAD#, ARCHIVED_SEQ#, APPLIED_THREAD#, APPLIED_SEQ#, Synchronized  FROM V$ARCHIVE_DEST_status where dest_id=1;

---- changing the archive log destination---------------------------------------
alter system set log_archive_dest_1='LOCATION=/orp053/p053_30/temp_arch' scope=both;

Check Archive Generation in GB:
-------------------------------
SELECT A.*,Round(A.Count#*B.AVG#/1024/1024/1024) Daily_Avg_GB FROM
(SELECT To_Char(First_Time,'YYYY-MM-DD') DAY,Count(1) Count#,Min(RECID) Min#,Max(RECID) Max#
FROM v$log_history 
GROUP BY To_Char(First_Time,'YYYY-MM-DD')
ORDER BY 1 DESC) A,
(SELECT Avg(BYTES) AVG#,Count(1) Count#,Max(BYTES) Max_Bytes,Min(BYTES) Min_Bytes
FROM v$log) B order by 1 asc; 

select 'ARCHIVE LOG REPORT',to_char(first_time,'DD-MON-RR') "Date",
to_char(sum(decode(to_char(first_time,'HH24'),'00',1,0)),'99') " 00",
to_char(sum(decode(to_char(first_time,'HH24'),'01',1,0)),'99') " 01",
to_char(sum(decode(to_char(first_time,'HH24'),'02',1,0)),'99') " 02",
to_char(sum(decode(to_char(first_time,'HH24'),'03',1,0)),'99') " 03",
to_char(sum(decode(to_char(first_time,'HH24'),'04',1,0)),'99') " 04",
to_char(sum(decode(to_char(first_time,'HH24'),'05',1,0)),'99') " 05",
to_char(sum(decode(to_char(first_time,'HH24'),'06',1,0)),'99') " 06",
to_char(sum(decode(to_char(first_time,'HH24'),'07',1,0)),'99') " 07",
to_char(sum(decode(to_char(first_time,'HH24'),'08',1,0)),'99') " 08",
to_char(sum(decode(to_char(first_time,'HH24'),'09',1,0)),'99') " 09",
to_char(sum(decode(to_char(first_time,'HH24'),'10',1,0)),'99') " 10",
to_char(sum(decode(to_char(first_time,'HH24'),'11',1,0)),'99') " 11",
to_char(sum(decode(to_char(first_time,'HH24'),'12',1,0)),'99') " 12",
to_char(sum(decode(to_char(first_time,'HH24'),'13',1,0)),'99') " 13",
to_char(sum(decode(to_char(first_time,'HH24'),'14',1,0)),'99') " 14",
to_char(sum(decode(to_char(first_time,'HH24'),'15',1,0)),'99') " 15",
to_char(sum(decode(to_char(first_time,'HH24'),'16',1,0)),'99') " 16",
to_char(sum(decode(to_char(first_time,'HH24'),'17',1,0)),'99') " 17",
to_char(sum(decode(to_char(first_time,'HH24'),'18',1,0)),'99') " 18",
to_char(sum(decode(to_char(first_time,'HH24'),'19',1,0)),'99') " 19",
to_char(sum(decode(to_char(first_time,'HH24'),'20',1,0)),'99') " 20",
to_char(sum(decode(to_char(first_time,'HH24'),'21',1,0)),'99') " 21",
to_char(sum(decode(to_char(first_time,'HH24'),'22',1,0)),'99') " 22",
to_char(sum(decode(to_char(first_time,'HH24'),'23',1,0)),'99') " 23"
from v$log_history
group by to_char(first_time,'DD-MON-RR')
order by 1
/

Check which session is generating more redo:
--------------------------------------------
rem 
rem Purpose: Transaction which generating more redo
rem This view contains the column BLOCK_CHANGES which indicates how much blocks have been changed
rem by the session. High values indicate a session generating lots of redo.
rem Run the query multiple times and examine the delta between each occurrence
rem of BLOCK_CHANGES. Large deltas indicate high redo generation by the session.
rem 

set pages 1000
set lines 140
SELECT s.sid, s.serial#, s.username, s.program,
i.block_changes
FROM v$session s, v$sess_io i
WHERE s.sid = i.sid
ORDER BY 5 asc, 1, 2, 3, 4;

Thread 1 cannot allocate new log, sequence 517
Private strand flush not complete

set linesize 100;
col member format a50;
select l.group#, lf.member, l.bytes/1024/1024 mb,  l.status, l.archived
from v$logfile lf, v$log l
where l.group# = lf.group#
order by 1, 2;


This shows the total free space remaining in the shared pool, the percentage free and the total space. 

Alternately, the following shows how memory is being used in the shared pool:

    select pool, name, sum(bytes) from v$sgastat
    where pool like '%large pool%'
    group by rollup (pool, name);

###
select POOL, round(bytes/1024/1024,0) FREE_MB
from v$sgastat
where name like '%free memory%';

#####

select pool, sum(bytes/1024/1024) from v$sgastat 
where pool is not null 
group by pool 
order by pool;

ASM:

select trim(round((((TOTAL_MB-USABLE_FILE_MB)/TOTAL_MB)*100),2)) from v$asm_diskgroup
... Usage of ASM Disk Groups
SELECT NAME, free_mb/1024 free_gb, total_mb/1024 total_gb, (FREE_MB/TOTAL_MB)*100 percent_free from V$ASM_DISKGROUP;
... all ASM devices
SELECT to_char(create_date,'yy.mm.dd hh24:mi') "yy.mm.dd hh24:mi",  name, failgroup, path from v$asm_disk order by name, 1, path;

... Un-Used ASM Devices
SELECT to_char(create_date,'yy.mm.dd hh24:mi') "yy.mm.dd hh24:mi", name, failgroup, path from v$asm_disk where name is null order by name, 1, path;

alter diskgroup DATA add failgroup S1 disk '/dev/s1_asm012' name data10s1 failgroup S2 disk '/dev/s2_asm012' name data10s2 ;

... ASM File status
SELECT name, path, mount_status, header_status, mode_status ,state, free_mb from v$asm_disk order by 2;

copy archivelog '+FRA/pr273/archivelog/2010_03_13/thread_1_seq_841.295.713538425' to '/u01/app/oracle/export/PR273/arch/thread_1_seq_841.295.713538425'

##############Dynanmic sql ###############

set head off
select 'EXEC DBMS_STATS.gather_schema_stats('''||username||''', estimate_percent => 15);' from dba_users where username not in ('SYS','SYSTEM','OUTLN','CTXSYS','WMSYS','PERFSTAT','DBSNMP');


select 'grant select on '||owner||'.'||object_name||' to ATLAS_PROD_READ  ; ' from dba_objects where object_type like 'TABLE' and owner 
like 'PR257LM';

select 'grant select on '||owner||'.'||object_name||' to ATLAS_PROD_READ  ; ' from dba_objects where object_type like 'TABLE' and owner 
like 'PR257WM';


select '!kill -9 '||spid
from v$process a, v$session b
where b.paddr = a.addr
and b.sid in &sid
/



ps -ef |grep LOCAL

all 1 are defunct process


########################## TABLESPACES & DATA-FILES ###########################################

select sum(bytes / (1024*1024*1024)) "DB Size in GB" from dba_data_files; 

select sum(bytes/1024/1024),tablespace_name from dba_data_files group by tablespace_name;

select TABLESPACE_NAME, BYTES_USED, BYTES_FREE from V$TEMP_SPACE_HEADER;

select MAX(BYTES), MAX(BLOCKS), COUNT(*) ,SUM(BYTES),   SUM(BLOCKS) from DBA_FREE_SPACE group by tablespace_name;

set linesize 200
set pagesize 200
col file_name for a60
select file_name,bytes/1024/1024,maxbytes/1024/1024 from dba_data_files where tablespace_name='&a' order by 1;
select file_name,bytes/1024/1024,maxbytes/1024/1024 from dba_temp_files where tablespace_name='&a';

ALTER TABLESPACE PSAPBTBSI ADD DATAFILE '/oracle/VA5/sapdata6/btbsi_7/btbsi.data7' SIZE 1024M;

ALTER TABLESPACE PSAPBTBSI ADD DATAFILE '+DATA1' SIZE 1024M;

select name,open_mode,database_role from gv$database;

select instance_name,host_name,status,logins,to_char(startup_time,'YYYY-MON-DD HH24:MI:SS') from gv$instance;

SELECT /* + RULE */  df.tablespace_name "Tablespace",
       df.bytes / (1024 * 1024) "Size (MB)",
       SUM(fs.bytes) / (1024 * 1024) "Free (MB)",
       Nvl(Round(SUM(fs.bytes) * 100 / df.bytes),1) "% Free",
       Round((df.bytes - SUM(fs.bytes)) * 100 / df.bytes) "% Used"
  FROM dba_free_space fs,
       (SELECT tablespace_name,SUM(bytes) bytes
          FROM dba_data_files
         GROUP BY tablespace_name) df
 WHERE fs.tablespace_name (+)  = df.tablespace_name
 GROUP BY df.tablespace_name,df.bytes
UNION ALL
SELECT /* + RULE */ df.tablespace_name tspace,
       fs.bytes / (1024 * 1024),
       SUM(df.bytes_free) / (1024 * 1024),
       Nvl(Round((SUM(fs.bytes) - df.bytes_used) * 100 / fs.bytes), 1),
       Round((SUM(fs.bytes) - df.bytes_free) * 100 / fs.bytes)
  FROM dba_temp_files fs,
       (SELECT tablespace_name,bytes_free,bytes_used
          FROM v$temp_space_header
         GROUP BY tablespace_name,bytes_free,bytes_used) df
 WHERE fs.tablespace_name (+)  = df.tablespace_name
 GROUP BY df.tablespace_name,fs.bytes,df.bytes_free,df.bytes_used
 ORDER BY 4 DESC;


select file_name, hwm, blocks total_blocks, blocks-hwm+1 shrinkage_possible
from dba_data_files a,
       ( select file_id, max(block_id+blocks) hwm
           from dba_extents
          group by file_id ) b
where a.file_id = b.file_id;

col TABLESPACE_NAME for a25
col TOT_PCT_USED for 99999
col TOT_PCT_FREE for 99999
SELECT * FROM (SELECT c.tablespace_name,ROUND(a.bytes/1048576,2) MB_Allocated,
ROUND(b.bytes/1048576,2) MB_Free,ROUND((a.bytes-b.bytes)/1048576,2) MB_Used,
ROUND(b.bytes/a.bytes * 100,2) tot_Pct_Free,ROUND((a.bytes-b.bytes)/a.bytes,2) * 100 tot_Pct_Used
FROM (SELECT tablespace_name,SUM(a.bytes) bytes FROM sys.DBA_DATA_FILES a GROUP BY tablespace_name) a,
(SELECT a.tablespace_name, NVL(SUM(b.bytes),0) bytes
FROM sys.DBA_DATA_FILES a, sys.DBA_FREE_SPACE b WHERE a.tablespace_name = b.tablespace_name (+)
AND a.file_id = b.file_id (+) GROUP BY a.tablespace_name) b,
sys.DBA_TABLESPACES c WHERE a.tablespace_name = b.tablespace_name(+)
AND a.tablespace_name = c.tablespace_name ) WHERE tot_Pct_Used >0  ORDER BY 6 desc;


set pagesize 200
set linesize 100
col FILE_NAME for a45
col BYTES  for a10
col MAXBYTES for a10
col AUTOEXTENSIBLE for a10
col STATUS for a10f
select FILE_NAME, BYTES /1024/1024 UsedMB, MAXBYTES/1024/1024 MaxMB,STATUS
from dba_data_files
where TABLESPACE_NAME='&tbs';



Shows usage of tbs below 10% space:
----------------------------------
SELECT df.tablespace_name "Tablespace",a.status,totalusedspace "Used MB",(df.totalspace - tu.totalusedspace) "Free MB",
df.totalspace "Total MB",round(100 * ((df.totalspace - tu.totalusedspace) / df.totalspace)) "Pct. Free"
FROM (SELECT tablespace_name, round(SUM(bytes) / 1048576) TotalSpace FROM dba_data_files
GROUP BY tablespace_name) df,(SELECT round(SUM(bytes) / (1024 * 1024)) totalusedspace,tablespace_name
FROM dba_segments GROUP BY tablespace_name) tu,dba_tablespaces a WHERE df.tablespace_name = tu.tablespace_name
and tu.tablespace_name=a.tablespace_name and a.status <> 'READ ONLY'
AND round(100 * ((df.totalspace - tu.totalusedspace) / df.totalspace)) < 10;

To Check Autoextensible Option:
------------------------------
select file_name,bytes/1024/1024,maxbytes/1024/1024,autoextensible from dba_data_files where autoextensible like 'YES';
select file_name,bytes/1024/1024,maxbytes/1024/1024,autoextensible from dba_temp_files where autoextensible like 'YES';

SELECT NAME, free_mb/1024 free_gb, total_mb/1024 total_gb, (FREE_MB/TOTAL_MB)*100 percent_free from V$ASM_DISKGROUP;


=========== to resize the datafiles ==

SELECT    'alter database datafile '''
       || f.file_name
       || ''' resize '
       || h.hwm
       || 'm;' stmt
  FROM (SELECT   CEIL (MAX (block_id + blocks) * (select value from v$parameter where name='db_block_size') / 1024 / 1024) hwm,
                 file_id
            FROM dba_extents
        GROUP BY file_id) h,
       (SELECT *
          FROM dba_data_files
         WHERE autoextensible = 'YES') f
 WHERE h.file_id = f.file_id;

/*****************************************************************************************/

SELECT    'alter database tempfile '''
       || f.file_name
       || ''' resize '
       || h.hwm
       || 'm;' stmt
  FROM (SELECT   CEIL (MAX (block_id + blocks) * (select value from v$parameter where name='db_block_size') / 1024 / 1024) hwm,
                 file_id
            FROM dba_extents
        GROUP BY file_id) h,
       (SELECT *
          FROM dba_temp_files
         WHERE autoextensible = 'YES') f
 WHERE h.file_id = f.file_id;


#################MANUAL TABLESPACE CREATION SCRIPT#######################


select 'create tablespace ' || df.tablespace_name || chr(10)
 || ' datafile ''' || df.file_name || ''' size ' || df.bytes 
 || decode(autoextensible,'NO',null, chr(10) || ' autoextend on maxsize ' 
 || maxbytes) 
 || chr(10) 
 || 'default storage ( initial ' || initial_extent 
 || decode (next_extent, null, null, ' next ' || next_extent )
 || ' minextents ' || min_extents
 || ' maxextents ' ||  decode(max_extents,'2147483645','unlimited',max_extents) 
 || ') ;' 
 from dba_data_files df, dba_tablespaces t
 where df.tablespace_name=t.tablespace_name and 
df.tablespace_name='UNDOTBS1' and df.FILE_ID=(select min(file_id) from dba_data_files where tablespace_name =df.tablespace_name)
union all
select 'ALTER tablespace ' || df.tablespace_name || ' ADD ' || chr(10)
 || ' datafile ''' || df.file_name || ''' size ' || df.bytes 
 || decode(autoextensible,'NO',null, chr(10) || ' autoextend on maxsize ' 
 || maxbytes) 
 || chr(10) 
 || 'default storage ( initial ' || initial_extent 
 || decode (next_extent, null, null, ' next ' || next_extent )
 || ' minextents ' || min_extents
 || ' maxextents ' ||  decode(max_extents,'2147483645','unlimited',max_extents) 
 || ') ;' "Script To Recreate Tablespaces"
 from dba_data_files df, dba_tablespaces t
 where df.tablespace_name=t.tablespace_name and 
df.tablespace_name='UNDOTBS1' and df.FILE_ID!=(select min(file_id) from dba_data_files where tablespace_name =df.tablespace_name)
/

OR

select 'create tablespace ' || df.tablespace_name || chr(10)
 || ' datafile ''' || df.file_name || ''' size ' || df.bytes 
 || decode(autoextensible,'N',null, chr(10) || ' autoextend on maxsize ' 
 || maxbytes) 
 || chr(10) 
 || 'default storage ( initial ' || initial_extent 
 || decode (next_extent, null, null, ' next ' || next_extent )
 || ' minextents ' || min_extents
 || ' maxextents ' ||  decode(max_extents,'2147483645','unlimited',max_extents) 
 || ') ;'
 from dba_data_files df, dba_tablespaces t
 where df.tablespace_name=t.tablespace_name
union all
select 'ALTER tablespace ' || df.tablespace_name || ' ADD ' || chr(10)
 || ' datafile ''' || df.file_name || ''' size ' || df.bytes 
 || decode(autoextensible,'NO',null, chr(10) || ' autoextend on maxsize ' 
 || maxbytes) 
 || chr(10) 
 || 'default storage ( initial ' || initial_extent 
 || decode (next_extent, null, null, ' next ' || next_extent )
 || ' minextents ' || min_extents
 || ' maxextents ' ||  decode(max_extents,'2147483645','unlimited',max_extents) 
 || ') ;' "Script To Recreate Tablespaces"
 from dba_data_files df, dba_tablespaces t
 where df.tablespace_name=t.tablespace_name 
/




For 8i : (Not sure , haven't tested it )
-------

spool gents.lst
set serveroutput on size 1000000
DECLARE

  CURSOR get_ts IS SELECT * FROM dba_tablespaces
                   WHERE tablespace_name != 'SYSTEM';

  CURSOR get_df (p_ts VARCHAR2) IS
                   SELECT * from dba_data_files
                   WHERE tablespace_name = p_ts
                   UNION ALL
                   SELECT * from dba_temp_files
                   WHERE tablespace_name = p_ts  ;

  l_str VARCHAR2(10);

BEGIN

FOR ts_rec IN get_ts LOOP

  dbms_output.put_line ('CREATE TABLESPACE '||ts_rec.tablespace_name);

  -- For each tablespace loop through the datafiles
  FOR df_rec IN get_df (ts_rec.tablespace_name) LOOP

    IF get_df%ROWCOUNT = 1 THEN
       l_str := 'DATAFILE';
    ELSE
       l_str := ',';
    END IF;

    dbms_output.put_line (l_str||' '
                ||chr(39)||df_rec.file_name||chr(39)
                ||' SIZE '||df_rec.bytes||' REUSE ');

    if df_rec.autoextensible = 'YES' then

       dbms_output.put_line (' AUTOEXTEND ON'
                             ||' NEXT '||df_rec.increment_by );

       if df_rec.maxbytes = 68719443968 then
          dbms_output.put_line (' MAXSIZE UNLIMITED');
       else
          dbms_output.put_line (' MAXSIZE '||df_rec.maxbytes);
       end if;

    end if;

  END LOOP;

/* Extent Management Clause */

   dbms_output.put_line  ('EXTENT MANAGEMENT ' ||ts_rec.extent_management );

   if ts_rec.extent_management = 'LOCAL' then

      if ts_rec.allocation_type = 'SYSTEM' then

         dbms_output.put_line (' AUTOALLOCATE ');

      else

         dbms_output.put_line (' UNIFORM SIZE '||ts_rec.initial_extent);

      end if;
 
   end if;

   if ts_rec.extent_management = 'DICTIONARY' then

     dbms_output.put_line ('DEFAULT STORAGE (INITIAL '||ts_rec.initial_extent
        ||' NEXT '||ts_rec.next_extent
        ||' MINEXTENTS '||ts_rec.min_extents
        ||' MAXEXTENTS '||ts_rec.max_extents
        ||' PCTINCREASE '||ts_rec.pct_increase||' ) ');

   end if;

   dbms_output.put_line  (' ONLINE;');
   dbms_output.new_line;

END LOOP;

END;
/ 
spool off


#################################TEMP##################################################

select sum(free_blocks) from gv$sort_segment where tablespace_name = 'TEMP';


"=== TEMP space utilization SID report"
select u.USERNAME,
  nvl2(QCSID,QCSID,d.sid) SID,ROUND((SUM(u.blocks*32/1024/1024)),2) "Used Space in GB" from gv$px_session a,gv$sort_usage u, gv$session d
  where SESSION_ADDR=d.SADDR(+)
  and a.sid(+) = d.sid
  group by u.USERNAME,nvl2(QCSID,QCSID,d.sid)
  having ROUND((SUM(u.blocks*32/1024/1024)),2) > 0
  order by username
/



set pages 1000 lines 132
col pct_used form 990.99
col tspace form a15
SELECT  tf.tablespace_name tspace, 
                tf.total_mb tblspc_sz,
                max_used_size* s.extent_size * p.value/1024/1024 hwm_mb,
                tf.total_mb - (tf.num_files * s.extent_size * p.value/1024/1024) total_mb,
                used_extents * s.extent_size * p.value/1024/1024 used_mb, 
                tf.total_mb - (tf.num_files * s.extent_size * p.value/1024/1024) -
                                 (used_extents * s.extent_size * p.value/1024/1024) free_mb, 
                (used_extents * s.extent_size * p.value/1024/1024)*100/
                                (tf.total_mb - (tf.num_files * s.extent_size * p.value/1024/1024)) pct_used
FROM    v$sort_segment s,
                v$parameter p,
                (
                                SELECT tablespace_name,
                                                sum(bytes)/1024/1024 total_mb,
                                                count(1) num_files
                                FROM   dba_temp_files
                                GROUP BY tablespace_name
                ) tf
WHERE tf.tablespace_name = s.tablespace_name 
AND       p.name = 'db_block_size'
;

Usage by session:

SELECT   b.TABLESPACE
       , b.segfile#
       , b.segblk#
       , ROUND (  (  ( b.blocks * p.VALUE ) / 1024 / 1024 ), 2 ) size_mb
       , a.SID
       , a.serial#
       , a.username
       , a.osuser
       , a.program
       , a.status
    FROM v$session a
       , v$sort_usage b
       , v$process c
       , v$parameter p
   WHERE p.NAME = 'db_block_size'
     AND a.saddr = b.session_addr
     AND a.paddr = c.addr
ORDER BY b.TABLESPACE
       , b.segfile#
       , b.segblk#
       , b.blocks;


SELECT SUM(u.blocks* p.value/1024/1024) sz_mb
FROM v$session s, v$sort_usage u, v$parameter p
WHERE s.saddr=u.session_addr
AND     p.name = 'db_block_size'; 


SELECT s.sid, s.username, u.tablespace, u.contents, u.extents, u.blocks, u.blocks* p.value/1024/1024 sz_mb
FROM v$session s, v$sort_usage u, v$parameter p
WHERE s.saddr=u.session_addr
AND     p.name = 'db_block_size'; 

blocks*16/1024 as total_MB,
    used_blocks*16/1024 as used_MB,
    free_blocks*16/1024 as free_MB
FROM   v$sort_segment;


SELECT   b.TABLESPACE,
         b.segfile#,
         b.segblk#,
         b.blocks,
   b.blocks*16/1024 as MB,
         a.SID,
         a.serial#,
         a.status
FROM     v$session a,
         v$sort_usage b
WHERE    a.saddr = b.session_addr
ORDER BY b.TABLESPACE,
         b.segfile#,
         b.segblk#,
         b.blocks;

select 
   srt.tablespace, 
   srt.segfile#, 
   srt.segblk#, 
   srt.blocks, 
   a.sid, 
   a.serial#, 
   a.username, 
   a.osuser, 
   a.status 
from 
   v$session    a,
   v$sort_usage srt 
where 
   a.saddr = srt.session_addr 
order by 
   srt.tablespace, srt.segfile#, srt.segblk#, 
   srt.blocks;

###################################UNDO & RBS#############################################

select sum(bytes/1024/1024),status from dba_undo_extents group by status;

select tablespace_name, status, sum(blocks) * 8192/1024/1024/1024 GB from dba_undo_extents group by tablespace_name, status;



#############Get the optimal undo_retention size to be increased#####################

 SELECT d.undo_size/(1024*1024) "ACTUAL UNDO SIZE [MByte]",
 SUBSTR(e.value,1,25) "UNDO RETENTION [Sec]",
 ROUND((d.undo_size / (to_number(f.value) *
 g.undo_block_per_sec))) "OPTIMAL UNDO RETENTION [Sec]"
 FROM (
 SELECT SUM(a.bytes) undo_size
 FROM v$datafile a,
 v$tablespace b,
 dba_tablespaces c
 WHERE c.contents = 'UNDO'
 AND c.status = 'ONLINE'
 AND b.name = c.tablespace_name
 AND a.ts# = b.ts#
 ) d,
 v$parameter e,
 v$parameter f,
 (
 SELECT MAX(undoblks/((end_time-begin_time)*3600*24))
 undo_block_per_sec
 FROM v$undostat
 ) g
 WHERE e.name = 'undo_retention'
 AND f.name = 'db_block_size'
 /



#############Get the optimal undo size in MB to be Increased#####################

SELECT d.undo_size/(1024*1024) "ACTUAL UNDO SIZE [MByte]",
SUBSTR(e.value,1,25) "UNDO RETENTION [Sec]",
(TO_NUMBER(e.value) * TO_NUMBER(f.value) * g.undo_block_per_sec) / (1024*1024) "NEEDED UNDO SIZE [MByte]"
FROM (SELECT SUM(a.bytes) undo_size FROM v$datafile a, v$tablespace b, dba_tablespaces c WHERE c.contents = 'UNDO' AND c.status = 'ONLINE' AND b.name = c.tablespace_name AND a.ts# = b.ts#) d, v$parameter e, v$parameter f, (SELECT MAX(undoblks/((end_time-begin_time)*3600*24)) undo_block_per_sec FROM v$undostat) g WHERE e.name = 'undo_retention' AND f.name = 'db_block_size';


###############Check Undo Usage##################################################

set line 200;
SELECT TO_CHAR(s.sid)||','||TO_CHAR(s.serial#) sid_serial,
NVL(s.username, 'None') orauser,
s.program,
r.name undoseg,
t.used_ublk * TO_NUMBER(x.value)/1024||'K' "Undo"
FROM sys.v_$rollname r,
sys.v_$session s,
sys.v_$transaction t,
sys.v_$parameter x
WHERE s.taddr = t.addr
AND r.usn = t.xidusn(+)
AND x.name = 'db_block_size'
/


SELECT segment_name, tablespace_name, bytes, blocks, extents,max_extents FROM dba_segments WHERE segment_type = 'ROLLBACK';

ALTER ROLLBACK SEGMENT rbs_one ONLINE; 

Changing Rollback Segment Storage:

This statement changes the STORAGE parameters for rbs_one:

ALTER ROLLBACK SEGMENT rbs_one STORAGE (NEXT 1000 MAXEXTENTS 20); 

Resizing a Rollback Segment:

This statements shrinks the rollback segment rbs_one:

ALTER ROLLBACK SEGMENT rbs_one SHRINK TO 100 M;


To monitor rollback usage (waits/gets should be < 1 %)

select name, waits, gets
from v$rollstat, v$rollname
where v$rollstat.usn = v$rollname.usn;

select owner,SEGMENT_NAME,NEXT_EXTENT,MAX_EXTENTS from dba_rollback_segs;


#######################Database Growth######################################

select to_char(creation_time, 'RRRR Month') "MONTH",
sum(bytes)/1024/1024 "GROWTH IN MB"
from sys.v_$datafile
where creation_time > SYSDATE-365
group by to_char(creation_time, 'RRRR Month');


##########################Dropping a Database################################

Manual Delete/Drop Database in 11gr2 via command line
There is two option to delete/drop database in oracle via DBCA or COMMAND line.

How to drop database via command line
Step:
1.	connect with sysdba user 

() CDBD01> sqlplus "/as sysdba"
SQL> startup mount
ORACLE instance started.

Total System Global Area 1319862272 bytes
Fixed Size                  2158064 bytes
Variable Size             838865424 bytes
Database Buffers          469762048 bytes
Redo Buffers                9076736 bytes
Database mounted.

SQL> alter system enable restricted session;

System altered.

SQL> drop database;

Database dropped.

Disconnected from Oracle Database 11g Enterprise Edition Release 11.2.0.2.0 - Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options

Important Point:
1. Database must be closed
2. database must be in restricted mode
3. drop database command will delete ORADATA FILES (control/redo/data file and SPFILE)
4. archive log and rman backup can be deleted via rman command
5. drop database will not delete any files on raw disk. we need to delete manually
6. registry entry need to delete manually
=======================================================================================================================

Note : Don’t/Never do this ops mode database.

##########################ORACLE USER ACCOUNTS & PRIVILEGES##################################

------------------------Account Details with LOGON_TIME & LOGOFF_TIME-------------------------------------

Before executing this, make sure we have enough space on TEMP tablespace

SELECT
A_AUDIT.USERNAME,
A_AUDIT.TIMESTAMP LOGIN_TIME,
A_AUDIT.LOGOFF_TIME
FROM DBA_AUDIT_SESSION A_AUDIT
WHERE
(A_AUDIT.USERNAME,A_AUDIT.TIMESTAMP) IN
(SELECT B_AUDIT.USERNAME,MAX(B_AUDIT.TIMESTAMP)
FROM DBA_AUDIT_SESSION B_AUDIT
GROUP BY B_AUDIT.USERNAME);

##########Creating profile for never expiring password###########

SQL> CREATE PROFILE NEW_PROFILE
  2   LIMIT PASSWORD_REUSE_MAX UNLIMITED
  3  PASSWORD_REUSE_TIME 30
  4  PASSWORD_LIFE_TIME UNLIMITED;

Profile created.


select distinct owner from dba_objects order by owner;

select distinct owner, object_type, count(*) from dba_objects where owner in ('OPTIMEBUDGET','OPTIMEBUDGETUSR') group by owner, object_type order by  owner;

select grantee, granted_role from dba_role_privs where GRANTEE in ('OPTIMEBUDGET','OPTIMEBUDGETUSR') order by grantee;

select distinct owner, privilege, count(*) from dba_tab_privs where grantee='OPTIMEBUDGETUSR' group by owner, privilege order by owner, privilege;

select GRANTEE, privilege from dba_sys_privs where GRANTEE in ('OPTIMEBUDGET') order by GRANTEE;

select 'alter user '||username||' identified by values '||REGEXP_SUBSTR(DBMS_METADATA.get_ddl ('USER',USERNAME), '''[^'']+''')||';' 

alter user MYTEST identified by values 'S:A4CE024B548C4C11C886A735F0D00314C1050C7A9C4FC492585BA2BC8520;D9402F621C938AC1'; 

select REGEXP_SUBSTR(DBMS_METADATA.get_ddl ('USER','MYUSER'), '''[^'']+''') PASSWD from dual;

#####To fetch User's password###############################################

set head off
set pages 0
set long 9999999

select 
   dbms_metadata.get_ddl('USER', username) || '/' usercreate
from 
   dba_users
where username='MARCO_O_OWN';

select name,password from sys.user$ where name='PMAG';


######################OBJECTS & SEGMENTS####################################

-------------Check TABLE size-------------------
select segment_name,segment_type,bytes/1024/1024 MB
 from dba_segments
 where segment_type='TABLE' and segment_name='TBL_ALIGN_ZIP_TERR_XREF';

set linesize 200
set pagesize 200
col object_name for a40
col segment_name for a40
select bytes/1024/1024,segment_name,owner,tablespace_name from dba_segments where segment_type='TABLE' and owner not in ('SYS','SYSTEM') and bytes > 20000000 order by 1;

--------------------All Objects Details--------------------------
SELECT COUNT(*),OBJECT_TYPE from dba_objects group by object_type;


-----------To identify table and extents problem-----------------

select segment_name, owner, extents, max_extents 
from dba_segments
where segment_type = 'TEMPORARY'
and (extents +1) >= max_extents;
OR
select owner, segment_name, max_extents, extents, tablespace_name from dba_segments where max_extents - extents < 10000000 and owner not in ('SYS','SYSTEM');

SELECT OWNER, SEGMENT_NAME, SEGMENT_TYPE, EXTENTS, MAX_EXTENTS,(EXTENTS/MAX_EXTENTS)*100
FROM DBA_SEGMENTS WHERE ((EXTENTS/MAX_EXTENTS)*100)  >= 90 and MAX_EXTENTS!=0

This tells if the pieces of free space are to small:

select owner, segment_name, next_extent/1024/1024, s.tablespace_name
from dba_segments s,
( select max(bytes) maxfree, tablespace_name
from dba_free_space group by tablespace_name) f
where s.next_extent > f.maxfree
and f.tablespace_name = s.tablespace_name;

This tells what pieces of free space you have TSNAME is the tablespace_name of interest:

select round(bytes/1024/1024), count(1)
from dba_free_space
where tablespace_name = '&TSNAME'
group by round(bytes/1024/1024);

select owner "Owner",
       tablespace_name "Tablespace",
       segment_name "Segment",
       extents "Extents",
       bytes/1024/1024 "Megabytes"
       from sys.dba_segments
       where upper(substr(segment_name,1,4)) != 'BIN$'
       and upper(substr(segment_name,1,3)) != 'DR$'
       and owner = 'IMPACT'
       and segment_name = 'KALKSAWERT'
       order by owner, extents desc, tablespace_name, segment_name;

ALTER TABLE <owner>.table STORAGE ( MAXEXTENTS integer);
ALTER TABLE <owner>.table STORAGE ( MAXEXTENTS UNLIMITED);

select count(*) from dba_objects;

Exporting tables into .csv:
--------------------------

STEP 1: Create a procedure named dump_table_to_csv

create or replace procedure dump_table_to_csv( p_tname in varchar2,
                                               p_dir   in varchar2,
                                               p_filename in varchar2 )
    is
        l_output        utl_file.file_type;
        l_theCursor     integer default dbms_sql.open_cursor;
        l_columnValue   varchar2(4000);
        l_status        integer;
        l_query         varchar2(1000)
                       default 'select * from ' || p_tname;
       l_colCnt        number := 0;
       l_separator     varchar2(1);
       l_descTbl       dbms_sql.desc_tab;
   begin
       l_output := utl_file.fopen( p_dir, p_filename, 'w' );
       execute immediate 'alter session set nls_date_format=''dd-mon-yyyy hh24:mi:ss''
';
   
       dbms_sql.parse(  l_theCursor,  l_query, dbms_sql.native );
       dbms_sql.describe_columns( l_theCursor, l_colCnt, l_descTbl );
  
       for i in 1 .. l_colCnt loop
          utl_file.put( l_output, l_separator || '"' || l_descTbl(i).col_name || '"' 
);
           dbms_sql.define_column( l_theCursor, i, l_columnValue, 4000 );
           l_separator := ',';
       end loop;
       utl_file.new_line( l_output );
   
       l_status := dbms_sql.execute(l_theCursor);
   
       while ( dbms_sql.fetch_rows(l_theCursor) > 0 ) loop
           l_separator := '';
           for i in 1 .. l_colCnt loop
               dbms_sql.column_value( l_theCursor, i, l_columnValue );
               utl_file.put( l_output, l_separator || l_columnValue );
               l_separator := ',';
           end loop;
           utl_file.new_line( l_output );
       end loop;
       dbms_sql.close_cursor(l_theCursor);
       utl_file.fclose( l_output );
   
       execute immediate 'alter session set nls_date_format=''dd-MON-yy'' ';
   exception
       when others then
           execute immediate 'alter session set nls_date_format=''dd-MON-yy'' ';
           raise;
   end;
   /

STEP 2:  exec dump_table_to_csv('CORM_NORTH.MIGRLOG','BFILE_DIR','MIGRLOG.csv');

INVALID OBJECTS:
---------------
COLUMN object_name FORMAT A30
SELECT owner,
       object_type,
       object_name,
       status
FROM   dba_objects
WHERE  status = 'INVALID'
ORDER BY owner, object_type, object_name;

Select decode( object_type, 'PACKAGE BODY', 'ALTER PACKAGE ' || OBJECT_NAME || ' COMPILE BODY;','ALTER ' || OBJECT_TYPE || ' ' || OBJECT_NAME || ' compile;' )
from dba_objects
where status = 'INVALID' and OWNER='SPECTRA_FS_BI'
order by object_type;

ASM DISK SPACE
----------------------------------------------
SET LINESIZE  145
SET PAGESIZE  9999
SET VERIFY    off

COLUMN group_name             FORMAT a20           HEAD 'Disk Group|Name'
COLUMN sector_size            FORMAT 99,999        HEAD 'Sector|Size'
COLUMN block_size             FORMAT 99,999        HEAD 'Block|Size'
COLUMN allocation_unit_size   FORMAT 999,999,999   HEAD 'Allocation|Unit Size'
COLUMN state                  FORMAT a11           HEAD 'State'
COLUMN type                   FORMAT a6            HEAD 'Type'
COLUMN total_mb               FORMAT 999,999,999   HEAD 'Total Size (MB)'
COLUMN used_mb                FORMAT 999,999,999   HEAD 'Used Size (MB)'
COLUMN pct_used               FORMAT 999.99        HEAD 'Pct. Used'

break on report on disk_group_name skip 1

compute sum label "Grand Total: " of total_mb used_mb on report

SELECT
    name                                     group_name
  , sector_size                              sector_size
  , block_size                               block_size
  , allocation_unit_size                     allocation_unit_size
  , state                                    state
  , type                                     type
  , total_mb                                 total_mb
  , (total_mb - free_mb)                     used_mb
  , ROUND((1- (free_mb / total_mb))*100, 2)  pct_used
FROM
    v$asm_diskgroup
ORDER BY
    name
/


select tablespace_name,sum(bytes/1024/1024) from dba_free_space where tablespace_name like '%UNDO%' group by tablespace_name;

select sum(bytes/1024/1024) as MB,status from dba_undo_extents where tablespace_name like '%UNDO%' group by status;

select undoblks,to_char(begin_time,'dd/mm/yy hh24:mi'),to_char(end_time,'dd/mm/yy hh24:mi') from v$undostat;

########################################### Process consuming more memory ?? #######################################################


select count(*) from v$session where status<>'ACTIVE';

select count(*) from v$session;


SELECT s.sid sid,s.serial# serial_id,lpad(s.status,9) session_status,lpad(s.username,12) oracle_username,lpad(s.osuser,9) os_username,lpad(p.spid,7) os_pid,s.program session_program,lpad(s.machine,14) session_machine,sstat.value  cpu_value 
FROM v$process p,v$session s,v$sesstat sstat,v$statname statname 
WHERE p.addr (+)= s.paddr AND s.sid = sstat.sid AND statname.statistic# = sstat.statistic# AND statname.name = 'CPU used by this session' ORDER BY cpu_value 
/

column sql_text format a90
column sid format 99999
column username a90
column status a60
select sql_text,sid,username,status
    from gv$session s, gv$sqlarea q
    where s.sql_hash_value = q.hash_value
    and s.sql_address = q.address
    and s.sid = &1;

########################################### CPU Usage ################################################

Select all users ACTIVE in the system : 

select sid, serial#,user#, Username, machine, program, server, status, command, type from v$session order by username;

To check what a user is doing :

select sid, serial#, status, server from v$session where username='######';


To check whats the waits :

column event format a60
column sid   format 99999
column seq#  format 99999
column parameters  format a70
select event, sid, seq#,
           wait_time,
           seconds_in_wait,
    /*     state,
           p1text, p1, p1raw,
           p2text, p2, p2raw,
           p3text, p3, p3raw
           p1text || ' = ' || p1 parm1,
           p2text || ' = ' || p2 parm2,
          p3text || ' = ' || p3 parm3
   */
          decode( p1text, null, null,
                  p1text || ' = ' || p1 ) ||
          decode( p2text, null, null,
                  ', ' || p2text || ' = ' || p2 ) ||
          decode( p3text, null, null,
                  ', ' || p3text || ' = ' || p3 )
          parameters
     from v$session_wait
    where event not in ( 'pmon timer', 'rdbms ipc message', 'smon timer',
                         'WMON goes to sleep',
                         'SQL*Net message from client' )
   order by event, p1, p2;



Then to check the Session stats :

select s.sid, s.value, n.name 
from v$sesstat s, v$statname n
where n.statistic# = s.statistic#
and s.value <> 0
and s.sid like '&sid'
and n.name like '&name'
and s.statistic# like '&statistic'
order by sid, n.name;

To check Usage for Active Sessions:
----------------------------------

SET PAUSE ON
SET PAUSE 'Press Return to Continue'
SET PAGESIZE 60
SET LINESIZE 300
 
COLUMN username FORMAT A30
COLUMN sid FORMAT 999,999,999
COLUMN serial# FORMAT 999,999,999
COLUMN "cpu usage (seconds)"  FORMAT 999,999,999.0000
 
SELECT
   s.username,
   t.sid,
   s.serial#,
   SUM(VALUE/100) as "cpu usage (seconds)"
FROM
   v$session s,
   v$sesstat t,
   v$statname n
WHERE
   t.STATISTIC# = n.STATISTIC#
AND
   NAME like '%CPU used by this session%'
AND
   t.SID = s.SID
AND
   s.status='ACTIVE'
AND
   s.username is not null
GROUP BY username,t.sid,s.serial#
/


################################### MVIEW ###########################################################


Refreshing Manually - exec dbms_mview.refresh('OWNGEMPAR.MVW_IND_INVITATION_NEW');

select QUERY from DBA_MVIEWS where OWNER='ADMBAR' and MVIEW_NAME='BAR_GLUE_DICTIONNARIES'; 
 

alter session set nls_date_format='dd-mm-yyyy hh24:mi:ss';

SELECT mview_name, refresh_mode, refresh_method, last_refresh_type, last_refresh_date FROM user_mviews;

SELECT mview_name, refresh_mode,staleness, refresh_method, last_refresh_type, last_refresh_date FROM dba_mviews order by 6;

select owner,name,to_char(LAST_REFRESH,'YYYY-MON-DD HH24:MI:ss') from DBA_MVIEW_REFRESH_TIMES order by LAST_REFRESH;

select mview_name from dba_mviews;

select * from dba_synonyms where synonym_name like 'MVIEW_CONTACT%';

SELECT CURRMVOWNER, CURRMVNAME FROM V$MVREFRESH

you could see indirectly if a materialized view is being refreshed by looking if a process has aquired locks on it : a materialized view should be modified only when refreshed (except FOR UPDATE materialized views used for two-way replication).
This query should return rows only when your materialized view is being refreshed:
SELECT sid
  FROM v$lock
 WHERE type = 'TX'
   AND id1 = (SELECT object_id
                FROM all_objects
               WHERE owner = :owner
                 AND object_name = :object_name)

OR
Materialized views that are defined to be refreshed on a schedule with "... START WITH... NEXT..." as part of their DDL will be executing under DBMS_JOB control. If the refresh of these MV's is in progress, you'll see values for THIS_DATE and THIS_SEC in the USER_JOBS (or DBA_JOBS) view for the corresponding job and/or a row in DBA_JOBS_RUNNING. 

OR

What you could do is to look for active transactions -- query V$TRANSACTION -- because a Refresh is a Transaction. Then, match all the SIDs you find in V$TRANSACTION with active SQLs.

spool ddl_list.sql
 select dbms_metadata.get_ddl('TABLE','DEPT','SCOTT') from dual; 
 select dbms_metadata.get_ddl('INDEX','DEPT_IDX','SCOTT') from dual;
 spool off;


###### RMAN Scripts #########################################################################

To check restore completion status :
------------------------------------------------------- 

select state, (UNDOBLOCKSDONE*100)/UNDOBLOCKSTOTAL from v$fast_start_transactions;


-------------------------Restore archive logs-----------------------------------

run 
{
allocate channel c1 type sbt_tape PARMS='BLKSIZE=1048576,ENV=(NB_ORA_CLIENT=xsph10p914s,NB_ORA_POLICY=P-E21-MI-ORA-ARCH)';
allocate channel c2 type sbt_tape PARMS='BLKSIZE=1048576,ENV=(NB_ORA_CLIENT=xsph10p914s,NB_ORA_POLICY=P-E21-MI-ORA-ARCH)';
allocate channel c3 type sbt_tape PARMS='BLKSIZE=1048576,ENV=(NB_ORA_CLIENT=xsph10p914s,NB_ORA_POLICY=P-E21-MI-ORA-ARCH)';
restore archivelog from logseq 30316 until logseq 30321 thread 1;
release channel c1;
release channel c2;
release channel c3;
}

run 
{
allocate channel c1 type sbt_tape PARMS='BLKSIZE=1048576,ENV=(NB_ORA_CLIENT=xsph10p914s,NB_ORA_POLICY=P-E21-MI-ORA-ARCH)';
allocate channel c2 type sbt_tape PARMS='BLKSIZE=1048576,ENV=(NB_ORA_CLIENT=xsph10p914s,NB_ORA_POLICY=P-E21-MI-ORA-ARCH)';
allocate channel c3 type sbt_tape PARMS='BLKSIZE=1048576,ENV=(NB_ORA_CLIENT=xsph10p914s,NB_ORA_POLICY=P-E21-MI-ORA-ARCH)';
restore archivelog from scn 13506214841969 until scn 13506204858684;
release channel c1;
release channel c2;
release channel c3;
}




----------------Restore from level0 Backup---------------------------------

run
{
ALLOCATE CHANNEL C1 DEVICE TYPE DISK;
ALLOCATE CHANNEL C2 DEVICE TYPE DISK;
ALLOCATE CHANNEL C3 DEVICE TYPE DISK;
ALLOCATE CHANNEL C4 DEVICE TYPE DISK;
ALLOCATE CHANNEL C5 DEVICE TYPE DISK;
ALLOCATE CHANNEL C6 DEVICE TYPE DISK;
ALLOCATE CHANNEL C7 DEVICE TYPE DISK;
set newname for datafile 1 to '/oradata4/O1P18177/system01.dbf';
set newname for datafile 2 to '/oradata4/O1P18177/undotbs01.dbf';
set newname for datafile 3 to '/oradata4/O1P18177/sysaux01.dbf';
set newname for datafile 4 to '/oradata3/O1P18177/users01.dbf';
set newname for datafile 5 to '/oradata4/O1P18177/tools01.dbf';
set newname for datafile 6 to '/oradata1/O1P18177/trackglo06.dbf';
set newname for datafile 7 to '/oradata1/O1P18177/trackfrance08.dbf';
set newname for datafile 8 to '/oradata4/O1P18177/zin01.dbf';
set newname for datafile 9 to '/oradata2/O1P18177/trackglo07.dbf';
set newname for datafile 10 to '/oradata4/O1P18177/trackfrancei02.dbf';
set newname for datafile 11 to '/oradata4/O1P18177/ilots01.dbf';
set newname for datafile 12 to '/oradata1/O1P18177/trackglo01.dbf';
set newname for datafile 13 to '/oradata2/O1P18177/trackgloi01.dbf';
set newname for datafile 14 to '/oradata4/O1P18177/ilotsi01.dbf';
set newname for datafile 15 to '/oradata2/O1P18177/trackglo02.dbf';
set newname for datafile 16 to '/oradata4/O1P18177/trackglo03.dbf';
set newname for datafile 17 to '/oradata4/O1P18177/trackglo04.dbf';
set newname for datafile 18 to '/oradata3/O1P18177/trackfrance01.dbf';
set newname for datafile 19 to '/oradata2/O1P18177/trackfrancei01.dbf';
set newname for datafile 20 to '/oradata3/O1P18177/trackfrance02.dbf';
set newname for datafile 21 to '/oradata2/O1P18177/trackfrance03.dbf';
set newname for datafile 22 to '/oradata2/O1P18177/trackfrance04.dbf';
set newname for datafile 23 to '/oradata2/O1P18177/trackfrance05.dbf';
set newname for datafile 24 to '/oradata3/O1P18177/trackfrance06.dbf';
set newname for datafile 25 to '/oradata1/O1P18177/trackfrance07.dbf';
set newname for datafile 26 to '/oradata4/O1P18177/trackglo05.dbf';
set newname for datafile 27 to '/oradata3/O1P18177/trackglo08.dbf';
set newname for datafile 28 to '/oradata1/O1P18177/trackfrance09.dbf';
set newname for datafile 29 to '/oradata4/O1P18177/esigns01.dbf';
set newname for datafile 30 to '/oradata4/O1P18177/esignsi01.dbf';
set newname for datafile 31 to '/oradata1/O1P18177/undotbs02.dbf';
set newname for datafile 32 to '/oradata1/O1P18177/trackfrance10.dbf';
set newname for datafile 33 to '/oradata3/O1P18177/undotbs03.dbf';
set newname for datafile 34 to '/oradata3/O1P18177/users02.dbf';
set newname for datafile 35 to '/oradata1/O1P18177/users03.dbf';
set newname for datafile 36 to '/oradata3/O1P18177/users04.dbf';
restore database;
switch datafile all;
}


-------------Re-linking RMAN-------------------------------------------------

cd $ORACLE_HOME/rdbms/lib 
make -f ins_rdbms.mk install 

Another example of relinking rman: 

$export ORACLE_SID=ATARPROD 
$export ORACLE_HOME=/oracle/app/oracle/product/10.2.0 
$export PATH=$ORACLE_HOME/bin:/usr/bin:/usr/sbin:/usr/ccs/bin:/usr/openwin/bin:/usr/dt/bin:/usr/bin/X11:/lib/64 
$export LD_LIBRARY_PATH_64=$ORACLE_HOME/lib 
$ls -lrt $ORACLE_HOME/bin/rman* 
$ cd $ORACLE_HOME/rdbms/lib 
$ make -f ins_rdbms.mk irman 
$ls -lrt $ORACLE_HOME/bin/rman* 
$rman target / 




------------------------Quick Backup with Details--------------------------------------------


run {
allocate channel t1 type disk;
allocate channel t2 type disk;
allocate channel t3 type disk;
backup database tag="Full_Database" format '/home/oracle/rman/backup_%d_set%s_piece%p_%T_%U' ;
sql 'alter system archive log current';
crosscheck archivelog all;
backup archivelog all format '/home/oracle/rman/arch_logs_%u';
backup current controlfile tag="Control_File" format '/home/oracle/rman/rman_backup_controlfile_%d_ctl.bckp';
RELEASE CHANNEL t1;
RELEASE CHANNEL t2;
RELEASE CHANNEL t3;
}





run {
allocate channel t1 type disk;
allocate channel t2 type disk;
allocate channel t3 type disk;

# Backup the whole DB
backup database spfile tag="Full_Database" format 'C:\app\RMAN_Backup\backup_%d_set%s_piece%p_%T_%U' ;

# Switch out of the current logfile
sql 'alter system archive log current';

# Backup the archived logs
crosscheck archivelog all;
backup archivelog all format 'C:\app\RMAN_Backup\arch_logs_%u';

# Backup a copy of the controlfile that contains records for the other backups just made
backup current controlfile tag="Control_File" format 'C:\app\RMAN_Backup\rman_backup_controlfile_%d_ctl.bckp' reuse;
# Creates a ccontrolfile copy on a specific location
backup as copy current controlfile format 'C:\app\RMAN_Backup\Control_File_copy.ctl';

#Crosschecking will check that the catalog/controlfile matches the physical backups. If a backup is missing, it will set the piece to 'EXPIRED' (missing)
CROSSCHECK BACKUP;

# Delete un-necessary backups. This command deletes backups based on the retention policy.
# Ignores any I/O errors, including those that occur when a backup is missing from disk or tape
DELETE NOPROMPT force OBSOLETE;

# Delete the expired backups.
DELETE NOPROMPT EXPIRED BACKUP;

#
delete noprompt expired archivelog all;

#

LIST BACKUP OF ARCHIVELOG FROM LOGSEQ _____;

RELEASE CHANNEL t1;
RELEASE CHANNEL t2;
RELEASE CHANNEL t3;
}

#

rman checksyntax @/tmp/goodcmdfile

#

show all;
show archivelog deletion policy;
show archivelog backup copies;
show auxname;
show backup optimization;
show [auxiliary] channel;
show channel for device type [disk |<media device>;
show controlfile autobackup;
show controlfile autobackup format;
show datafile backup copies;
show default device type;
show retention policy;
show encryption algorithm;
show encryption for [database | tablespace];
show exclude;
show maxsetsize;
show retention policy;
show snapshot controlfile name;
show compression algorithm;
show snapshot controlfile name;



Non-default RMAN configuration settings can be viewed from  V$RMAN_CONFIGURATION.

Making Compressed Backup Sets the Default : configure device type disk backup type to compressed backupset;
					    configure device type sbt backup type to compressed backupset;

RMAN Compression Algorithm :
---------------------------
select algorithm_name,algorithm_description, is_default
from v$rman_compression_algorithm;

RMAN> show compression algorithm;

configure compression algorithm to bzip2; (bzip2 is default before 11g)
configure compression algorithm to zlib;  (zlib is default since 11g)

Skipping Previously backed-up files :
-----------------------------------

RMAN> configure backup optimization on;

RMAN> backup database force; #This cmd will backup all files irrespective of the optimization setting#

RMAN> configure backup optimization off;

Configuring Automatic Channels :
-------------------------------

RMAN> configure default device type to sbt;

RMAN> show device type;

RMAN> configure channel device type disk maxpiecesize 1g;

Creating a Backup Retention Policy :
-----------------------------------

RMAN> configure retention policy to recovery window of 7 days;

RMAN> configure retention policy to redundancy 2;

RMAN> show retention policy;

Configuring an Archived Redo Log Deletion Policy :
-------------------------------------------------

RMAN> configure archivelog deletion policy to
2> backed up 2 times to sbt;

The preceding configure command specifies that once an archived redo log has been
backed up twice to tape, it’s eligible for deletion from all archived redo log locations, including
the flash recovery area. The configuration of an archived redo log deletion policy is a new feature
introduced in the Oracle Database 11g release.


RMAN reads the control file of the target database and copies the RMAN metadata into tables in the 
recovery catalog. After registration, the control file and the recovery catalog will contain identical
information regarding RMAN backups.

Enabling Block Change Tracking :
------------------------------

alter system set db_create_file_dest='/u01/app/oracle/dfiles' scope= both;

alter database enable block change tracking;

alter database enable block change tracking using file '/u05/app/oracle/change_track.txt';

To disable: alter database disable block change tracking;

V$BLOCK_CHANGE_TRACKING

Procedure to move the change tracking file :
-------------------------------------------
select filename from v$block_change_tracking;

Shut down the database.

mv /u05/app/oracle/change_trck.f /u10/app/oracle/change_track.f

startup mount

alter database rename file '/u05/app/oracle/change_track.f' to '/u10/app/oracle/change_track.f';

alter database open;


#######################################Data Guard Physical Standby Setup in Oracle Database 11gR2#######################################

On Primary Server :

1. Check that the primary database is in archivelog mode. If not, make it in archivelog mode.

2. ALTER DATABASE FORCE LOGGING;

3. Check the setting for the DB_NAME and DB_UNIQUE_NAME parameters. In this case they are both set to "DB11G" on the primary database.

SQL> show parameter db_name

NAME				     TYPE	 VALUE
------------------------------------ ----------- ------------------------------
db_name 			     string	 DB11G

SQL> show parameter db_unique_name

NAME				     TYPE	 VALUE
------------------------------------ ----------- ------------------------------
db_unique_name			     string	 DB11G


4. ALTER SYSTEM SET LOG_ARCHIVE_CONFIG='DG_CONFIG=(DB11G,DB11G_STBY)';

5. ALTER SYSTEM SET LOG_ARCHIVE_DEST_2='SERVICE=db11g_stby NOAFFIRM ASYNC VALID_FOR=(ONLINE_LOGFILES,PRIMARY_ROLE) DB_UNIQUE_NAME=DB11G_STBY';
   ALTER SYSTEM SET LOG_ARCHIVE_DEST_STATE_2=ENABLE;

6. ALTER SYSTEM SET LOG_ARCHIVE_FORMAT='%t_%s_%r.arc' SCOPE=SPFILE;
   ALTER SYSTEM SET LOG_ARCHIVE_MAX_PROCESSES=30;
   ALTER SYSTEM SET REMOTE_LOGIN_PASSWORDFILE=EXCLUSIVE SCOPE=SPFILE;

7. In addition to the previous setting, it is recommended to make sure the primary is ready to switch roles to become a standby.
   For that to work properly we need to set the following parameters. Adjust the *_CONVERT parameters to account for your filename
   and path differences between the servers.
   
   ALTER SYSTEM SET FAL_SERVER=DB11G_STBY;
   --ALTER SYSTEM SET DB_FILE_NAME_CONVERT='DB11G_STBY','DB11G' SCOPE=SPFILE;
   --ALTER SYSTEM SET LOG_FILE_NAME_CONVERT='DB11G_STBY','DB11G'  SCOPE=SPFILE;
   ALTER SYSTEM SET STANDBY_FILE_MANAGEMENT=AUTO;

8. Service Setup: Entries for the primary and standby databases are needed in the "$ORACLE_HOME/network/admin/tnsnames.ora" files on both servers.

   DB11G =
  (DESCRIPTION =
    (ADDRESS_LIST =
      (ADDRESS = (PROTOCOL = TCP)(HOST = ol5-112-dga1)(PORT = 1521))
    )
    (CONNECT_DATA =
      (SERVICE_NAME = DB11G.WORLD)
    )
  )

   DB11G_STBY =
  (DESCRIPTION =
    (ADDRESS_LIST =
      (ADDRESS = (PROTOCOL = TCP)(HOST = ol5-112-dga2)(PORT = 1521))
    )
    (CONNECT_DATA =
      (SERVICE_NAME = DB11G.WORLD)
    )
  )

9. Backup Primary Database : If you are planning to use an active duplicate to create the standby database, then this step is unnecessary. For a 
                             backup-based duplicate, or a manual restore, take a backup of the primary database.

   $ rman target=/

     RMAN> BACKUP DATABASE PLUS ARCHIVELOG;

10. Create Standby Controlfile and PFILE :
    
    ALTER DATABASE CREATE STANDBY CONTROLFILE AS '/tmp/db11g_stby.ctl';
    CREATE PFILE='/tmp/initDB11G_stby.ora' FROM SPFILE;
    
    Amend the PFILE making the entries relevant for the standby database. I'm making a replica of the original server, so in my case I only had to
    amend the following parameters.

    *.db_unique_name='DB11G_STBY'
    *.fal_server='DB11G'
    *.log_archive_dest_2='SERVICE=db11g ASYNC VALID_FOR=(ONLINE_LOGFILES,PRIMARY_ROLE) DB_UNIQUE_NAME=DB11G'


Standby Server Setup (Manual)

1. Copy Files :

   Create the necessary directories on the standby server.
   $ mkdir -p /u01/app/oracle/oradata/DB11G
   $ mkdir -p /u01/app/oracle/fast_recovery_area/DB11G
   $ mkdir -p /u01/app/oracle/admin/DB11G/adump

2. Copy the files from the primary to the standby server.
   
   $ # Standby controlfile to all locations.
   $ scp oracle@ol5-112-dga1:/tmp/db11g_stby.ctl /u01/app/oracle/oradata/DB11G/control01.ctl
   $ cp /u01/app/oracle/oradata/DB11G/control01.ctl /u01/app/oracle/fast_recovery_area/DB11G/control02.ctl

   $ # Archivelogs and backups
   $ scp -r oracle@ol5-112-dga1:/u01/app/oracle/fast_recovery_area/DB11G/archivelog /u01/app/oracle/fast_recovery_area/DB11G
   $ scp -r oracle@ol5-112-dga1:/u01/app/oracle/fast_recovery_area/DB11G/backupset /u01/app/oracle/fast_recovery_area/DB11G

   $ # Parameter file.
   $ scp oracle@ol5-112-dga1:/tmp/initDB11G_stby.ora /tmp/initDB11G_stby.ora

   $ # Remote login password file.
   $ scp oracle@ol5-112-dga1:$ORACLE_HOME/dbs/orapwDB11G $ORACLE_HOME/dbs

Notice, the backups were copied across to the standby server as part of the FRA copy. If your backups are not held within the 
FRA, you must make sure you copy them to the standby server and make them available from the same path as used on the primary server.


3. Start Listener : Make sure the listener is started on the standby server.

4. Restore Backup : Create the SPFILE form the amended PFILE.

                    $ export ORACLE_SID=DB11G
		    $ sqlplus / as sysdba

		    SQL> CREATE SPFILE FROM PFILE='/tmp/initDB11G_stby.ora';

  Restore the backup files.

 		    $ export ORACLE_SID=DB11G
		    $ rman target=/

		    RMAN> STARTUP MOUNT;
		    RMAN> RESTORE DATABASE;


5. Create Redo Logs : Create online redo logs for the standby. It's a good idea to match the configuration of the primary server.
		      
		      ALTER SYSTEM SET STANDBY_FILE_MANAGEMENT=MANUAL;
		      ALTER DATABASE ADD LOGFILE ('/u01/app/oracle/oradata/DB11G/online_redo01.log') SIZE 50M;
		      ALTER DATABASE ADD LOGFILE ('/u01/app/oracle/oradata/DB11G/online_redo02.log') SIZE 50M;
		      ALTER DATABASE ADD LOGFILE ('/u01/app/oracle/oradata/DB11G/online_redo03.log') SIZE 50M;
		      ALTER SYSTEM SET STANDBY_FILE_MANAGEMENT=AUTO;


			


-----------------------------------------------------------------------------------
crosscheck archivelog SEQUENCE BETWEEN 91405 AND 93404;

copy archivelog '+FRA/pr273/archivelog/2010_03_13/thread_1_seq_841.295.713538425' to '/u01/app/oracle/export/PR273/arch/thread_1_seq_841.295.713538425'

run{
allocate channel t1 type 'sbt_tape';
allocate channel t2 type 'sbt_tape';
backup
  not backed up
  format 'arc_%d_%t_%U'
  archivelog all
  delete input;
release channel t1;
release channel t2;
}


  backup
  not backed up
  format 'arc_%d_%t_%U'
  archivelog sequence between 93991 and 94091

  run{
2> allocate channel t1 type 'sbt_tape';
3> send 'NB_ORA_SERV=nbprodcl1, NB_ORA_POLICY=KDC_PR_AIX_ORCL_IPFR_T2_144_lakripfpr1,NB_ORA_CLIENT=lakripfpr1_ha';
4> set archivelog destination to '/backup/archivelogs';
5> restore archivelog sequence 329 from tag 'TAG20091206T215041';
6> release channel t1;
7> }


run {
allocate channel t1 type 'sbt_tape';
send 'NB_ORA_SERV=nbprodcl1,NB_ORA_SCHED=hot, NB_ORA_POLICY=Q9_DR_AIX_ORCL_IPFR_T1_144,NB_ORA_CLIENT=laq9ipfdr1_ha';
set until time "to_date('2009 DEC 06 20:00','yyyy mon dd hh24:mi')";
restore controlfile '/tmp/backctl.ctl';
release channel t1;
}


run {
backup
filesperset=10
current controlfile
format '/backup/ctlfile_%d.%s_%p_%t'
(archivelog all format '/backup/dbarch_%d.%s_%p_%t'
delete input);
}


run{
 allocate channel t1 type 'sbt_tape';
 send 'NB_ORA_POLICY=KDC_PR_WIN_ORCL_T2_144, NB_ORA_SCHED=hot, NB_ORA_SERV=nbprodcl1';
 set archivelog destination to 'L:\restore';
 RESTORE archivelog sequence 25853 from tag 'TAG20091226T201845';
 release channel t1;
 }
  ############
SQL> select MEDIA from v$backup_piece where HANDLE = 'arc_P053_20100104_lbl2kdej_1707_1_707409363';

MEDIA
-----------------------------------------------------------------
L20302


RMAN SESSION LONGOPS   Leave a comment
REM RMAN Progress
set linesize 200
set pagesize 200
alter session set nls_date_format='dd/mm/yy hh24:mi:ss'
/
select SID,opname, START_TIME,TOTALWORK, sofar, (sofar/totalwork) * 100 done,
sysdate + TIME_REMAINING/3600/24 end_at
from v$session_longops
where totalwork > sofar
AND opname NOT LIKE '%aggregate%'
AND opname like 'RMAN%'
order by DONE
/

REM RMAN wiats
set lines 200
column sid format 9999
column spid format 99999
column client_info format a25
column event format a40
column secs format 9999
SELECT SID, SPID, CLIENT_INFO, event, seconds_in_wait secs, p1, p2, p3
FROM V$PROCESS p, V$SESSION s
WHERE p.ADDR = s.PADDR
and CLIENT_INFO like 'rman channel=%'
/


 list backup of database completed between "to_date('25/07/2014','mm/dd/yyyy')" and "to_date('28/07/2014','mm/dd/yyyy')";

 list backup of datafile 1 completed between '06-OCT-08' and '25-DEC-2008';



#########################FRA###############################################

To Size & Create FRA : 
----------------------
alter system set db_recovery_size = 4G;
alter system set db_recovery_dest = '/home/oracle/flasharea';

To Resize FRA :
---------------
alter system set db_recovery_file_dest_size = 10G;

To view,remove and create Restore Points :
-----------------------------------------------------------
select name, storage_size from v$restore_point;

drop restore point rp2;

create restore point rp1;

create guaranteed restore point rp1;

To Restore :
------------ 
flashback database to rp1;


To Turn-Off flashback:
----------------------
alter database flashback off;

To view type of files in FRA :
------------------------------
select * from v$recovery_file_dest;

To view spaces used by diff. files in FRA:
------------------------------------------
select * from v$flash_recovery_area_usage;

select
file_type,
space_used*percent_space_used/100/1024/1024 used,
space_reclaimable*percent_space_reclaimable/100/1024/1024 reclaimable,
frau.number_of_files
from v$recovery_file_dest rfd, v$flash_recovery_area_usage frau;

Configuring Archived Redo logs to go to the FRA:
------------------------------------------------
alter system set log_archive_dest_1 = 'LOCATION=USE_DB_RECOVERY_FILE_DEST';

show parameter log_archive_dest_state_1;

select name from v$archived_log order by completion_time;

To backup everything from FRA to the tape:
-----------------------------------------

backup recovery area

To delete backups from the FRA:
------------------------------

delete backupset 157;

delete archivelog from logseq=78 until logseq=79;

Reinstating a Damaged Datafile from an Image Copy:
-------------------------------------------------

RMAN> list copy of datafile 5;

Take the damaged datafile offline, if not offline already:
RMAN> sql 'alter database datafile 5 offline';

RMAN> switch datafile 5 to copy;

RMAN> recover datafile 5;

RMAN> sql 'alter database datafile 5 online';





###################Check Offline Backup Status#############################


set lines 220 
set pages 1000 
col cf for 9,999 
col df for 9,999 
col elapsed_seconds heading "ELAPSED|SECONDS"
col i0 for 9,999 
col i1 for 9,999 
col l for 9,999 
col output_mbytes for 9,999,999 heading "OUTPUT|MBYTES"
col session_recid for 999999 heading "SESSION|RECID"
col session_stamp for 99999999999 heading "SESSION|STAMP"
col status for a10 trunc 
col time_taken_display for a10 heading "TIME|TAKEN"
col output_instance for 9999 heading "OUT|INST"
select
j.session_recid, j.session_stamp, 
to_char(j.start_time, 'yyyy-mm-dd hh24:mi:ss') start_time, 
to_char(j.end_time, 'yyyy-mm-dd hh24:mi:ss') end_time, 
(j.output_bytes/1024/1024) output_mbytes, j.status, j.input_type, 
decode(to_char(j.start_time, 'd'), 1, 'Sunday', 2, 'Monday', 
3, 'Tuesday', 4, 'Wednesday', 
5, 'Thursday', 6, 'Friday', 
7, 'Saturday') dow, 
j.elapsed_seconds, j.time_taken_display, 
x.cf, x.df, x.i0, x.i1, x.l, 
ro.inst_id output_instance 
from V$RMAN_BACKUP_JOB_DETAILS j 
left outer join (select
d.session_recid, d.session_stamp, 
sum(case when d.controlfile_included = 'YES' then d.pieces else 0 end) CF, 
sum(case when d.controlfile_included = 'NO'
and d.backup_type||d.incremental_level = 'D' then d.pieces else 0 end) DF, 
sum(case when d.backup_type||d.incremental_level = 'D0' then d.pieces else 0 end) I0, 
sum(case when d.backup_type||d.incremental_level = 'I1' then d.pieces else 0 end) I1, 
sum(case when d.backup_type = 'L' then d.pieces else 0 end) L 
from
V$BACKUP_SET_DETAILS d 
join V$BACKUP_SET s on s.set_stamp = d.set_stamp and s.set_count = d.set_count 
where s.input_file_scan_only = 'NO'
group by d.session_recid, d.session_stamp) x 
on x.session_recid = j.session_recid and x.session_stamp = j.session_stamp 
left outer join (select o.session_recid, o.session_stamp, min(inst_id) inst_id 
from GV$RMAN_OUTPUT o 
group by o.session_recid, o.session_stamp) 
ro on ro.session_recid = j.session_recid and ro.session_stamp = j.session_stamp 
where j.start_time > trunc(sysdate)-&NUMBER_OF_DAYS and input_type like '%FULL%' order by j.start_time;


set lines 220 
set pages 1000 
col cf for 9,999 
col df for 9,999 
col elapsed_seconds heading "ELAPSED|SECONDS"
col i0 for 9,999 
col i1 for 9,999 
col l for 9,999 
col output_mbytes for 9,999,999 heading "OUTPUT|MBYTES"
col session_recid for 999999 heading "SESSION|RECID"
col session_stamp for 99999999999 heading "SESSION|STAMP"
col status for a10 trunc 
col time_taken_display for a10 heading "TIME|TAKEN"
col output_instance for 9999 heading "OUT|INST"
select
j.session_recid, j.session_stamp, 
to_char(j.start_time, 'yyyy-mm-dd hh24:mi:ss') start_time, 
to_char(j.end_time, 'yyyy-mm-dd hh24:mi:ss') end_time, 
(j.output_bytes/1024/1024) output_mbytes, j.status, j.input_type, 
decode(to_char(j.start_time, 'd'), 1, 'Sunday', 2, 'Monday', 
3, 'Tuesday', 4, 'Wednesday', 
5, 'Thursday', 6, 'Friday', 
7, 'Saturday') dow, 
j.elapsed_seconds, j.time_taken_display, 
x.cf, x.df, x.i0, x.i1, x.l, 
ro.inst_id output_instance 
from V$RMAN_BACKUP_JOB_DETAILS j 
left outer join (select
d.session_recid, d.session_stamp, 
sum(case when d.controlfile_included = 'YES' then d.pieces else 0 end) CF, 
sum(case when d.controlfile_included = 'NO'
and d.backup_type||d.incremental_level = 'D' then d.pieces else 0 end) DF, 
sum(case when d.backup_type||d.incremental_level = 'D0' then d.pieces else 0 end) I0, 
sum(case when d.backup_type||d.incremental_level = 'I1' then d.pieces else 0 end) I1, 
sum(case when d.backup_type = 'L' then d.pieces else 0 end) L 
from
V$BACKUP_SET_DETAILS d 
join V$BACKUP_SET s on s.set_stamp = d.set_stamp and s.set_count = d.set_count 
where s.input_file_scan_only = 'NO'
group by d.session_recid, d.session_stamp) x 
on x.session_recid = j.session_recid and x.session_stamp = j.session_stamp 
left outer join (select o.session_recid, o.session_stamp, min(inst_id) inst_id 
from GV$RMAN_OUTPUT o 
group by o.session_recid, o.session_stamp) 
ro on ro.session_recid = j.session_recid and ro.session_stamp = j.session_stamp 
where j.start_time > trunc(sysdate)-&NUMBER_OF_DAYS 
order by j.start_time ;


Set lines 200
COL SESSION_KEY 999999
COL STATUS FORMAT a10
COL INPUT_TYPE FORMAT a15
COL hrs FORMAT 9999.99
SELECT SESSION_KEY, INPUT_TYPE, STATUS,
TO_CHAR(START_TIME,'mm/dd/yy hh24:mi') start_time,
TO_CHAR(END_TIME,'mm/dd/yy hh24:mi') end_time,
ELAPSED_SECONDS/3600 hrs
FROM V$RMAN_BACKUP_JOB_DETAILS
--where input_type = 'ARCHIVELOG'
ORDER BY SESSION_KEY;


select sid, start_time, totalwork sofar, (sofar/totalwork) * 100 pct_done from v$session_longops 
where totalwork > sofar AND opname NOT LIKE '%aggregate%' AND opname like 'RMAN%';


set lines 200 pages 1200
col username format a15
col message format a80
col STATUS format a20
select (select name from v$database) db_name,SID,message,to_char(START_TIME,'dd-MON-yyyy hh:mm:ss') START_TIME,
round((sofar/totalwork) * 100 ,2)||'% Completed ' STATUS from v$session_longops where totalwork > sofar AND opname like 'RMAN%';


  
############## STANDBY ###########################################

startup nomount;
alter database mount standby database;
ALTER DATABASE RECOVER MANAGED STANDBY DATABASE  disconnect from session;

======= to cancel the media recovery ======

 RECOVER MANAGED STANDBY DATABASE CANCEL;
-----------------------------------------------
select error from v$archive_dest;

SELECT PROCESS, STATUS FROM V$MANAGED_STANDBY;

select max(sequence#),thread# from v$archived_log where COMPLETION_TIME < sysdate -2 group by thread#

select max(sequence#) from v$archived_log;

select * from v$archive_gap;

select max(sequence#) from v$log_history;

desc v$archived_log;

sho parameter standby;

select * from v$managed_standby;

alter database recover managed standby database disconnect;

select thread#,max(sequence#) from v$archived_log where applied='YES' group by thread#;

select sequence#, applied,to_char(TIMESTAMP,'HH24:MI:SS DD-MON-YYYY') from dba_logstdby_log order by 1;


############ standby Rebuild ############

In primary:

alter database create standby control file as '<file name>';

invoke rman;

connect target /
 

 copy datafile 1 to '<file name>';

 exit


 copy control file and datafile to DR

 in DR

 shutdown immediate;

 clear the datafiles and control files

 copy the control file and datafiles to the original location; 

 make sure archives are there in the disk 

 startup nomount ; (if spfile else startup pfile='')
 alter database mount standby database;
ALTER DATABASE RECOVER MANAGED STANDBY DATABASE  disconnect from session;
Addition to standy database files=====================

alter tablespace PDBK0_DATA_008 add datafile '/orpdbk0/pdbk0_28/pdbk0_data_008_31.dbf' size 1000m;
alter tablespace PDBK0_DATA_008 add datafile '/orpdbk0/pdbk0_28/pdbk0_data_008_31.dbf' size 1000m;
ALTER DATABASE CREATE DATAFILE '/orpdbk0/pdbk0_05/pdbk0_data_008_31.dbf' AS '/orpdbk0/pdbk0_05/pdbk0_data_008_31.dbf'
ALTER DATABASE CREATE DATAFILE '/orpdbk0/pdbk0_28/pdbk0_data_008_31.dbf' AS '/orpdbk0/pdbk0_28/pdbk0_data_008_31.dbf'

########### BLOCKING,WAITING & LOCKING ########################################################

------------sql statements currently executing-------------------

select sql_text,sid,username,status
from gv$session s, gv$sqlarea q
where s.sql_hash_value = q.hash_value
and s.sql_address = q.address
and s.sid = &1;

select p.spid from v$session s, v$process p where s.sid=&1 and s.paddr=p.addr

select s.sid from v$session s, v$process p where p.spid=&1 and s.paddr=p.addr

------------------------------------------------------------------

column lock_type format a12
column mode_held format a10
column mode_requested format a10
column blocking_others format a20
column username format a10
SELECT	session_id
,	lock_type
,	mode_held
,	mode_requested
,	blocking_others
,	lock_id1
FROM	dba_locks l
WHERE 	lock_type NOT IN ('Media Recovery', 'Redo Thread')
and BLOCKING_OTHERS like 'Blocking'
/

select do.OWNER, do.OBJECT_NAME, do.OBJECT_ID, 
       lo.SESSION_ID, lo.ORACLE_USERNAME, lo.OS_USER_NAME, 
       lo.PROCESS, lo.LOCKED_MODE 
from   dba_objects do, v$locked_object lo 



set serveroutput on format wrapped
declare
cursor c1 is select holding_session,waiting_session from dba_waiters;

H_OSUSER  varchar2(100);
H_PROGRAM varchar2(100);
H_OSPROC  number(10);
W_OSUSER  varchar2(100);
w_PROGRAM varchar2(100);
W_SQLTEXT varchar2(2000);
W_OBJECT  varchar2(100);
W_ROW     number(10);
W_BLOCK   number(10);
W_FILE    varchar2(500);
w_COUNT   number(10);
W_OSPROC  number(10);

begin
dbms_output.enable(32000);
-- loopa igenom resultatet.
   for rec1 in c1 loop
      select a.osuser,a.program,b.spid
      into   H_OSUSER,H_PROGRAM,H_OSPROC
      from   v$session a, v$process b
      where  sid=rec1.holding_session
      and    a.paddr=b.addr;

      select a.osuser,a.program,b.object_name,a.ROW_WAIT_ROW#,d.name,a.ROW_WAIT_BLOCK#,c.spid
      into   W_OSUSER,W_PROGRAM,W_OBJECT,w_ROW,W_FILE,W_BLOCK,W_OSPROC
      from   v$session a, dba_objects b, v$datafile d, v$process c
      where  a.ROW_WAIT_OBJ#=b.object_id
      and    a.row_wait_file# = d.file#
      and    c.addr           = a.paddr
      and    a.sid            = rec1.waiting_session;

      select count(1)
      into   W_COUNT
      from   v$sqlarea a, v$session b
      where  b.sid     = rec1.waiting_session
      and    a.address = b.sql_address;

      if ( W_COUNT = 1 ) then
         select a.sql_text
         into   W_SQLTEXT
         from   v$session b, v$sqlarea a
         where  b.sid     = rec1.waiting_session
         and    a.address = b.sql_address;
      else
         W_SQLTEXT:='Statement not in Cache';
      end if;

      dbms_output.put_line('-------------------------------------------------------------------');
      dbms_output.put_line('HOLDING SESSION');
      dbms_output.put_line('=================');
      dbms_output.put_line('SID.........= '||rec1.holding_session);
      dbms_output.put_line('OSUSER......= '||H_OSUSER);
      dbms_output.put_line('PROGRAM.....= '||H_PROGRAM);
      dbms_output.put_line('OS PROCESS..= '||H_OSPROC);
      dbms_output.put_line(' ');
      dbms_output.put_line('WAITING SESSION');
      dbms_output.put_line('=================');
      dbms_output.put_line('SID.........= '||rec1.waiting_session);
      dbms_output.put_line('OSUSER......= '||W_OSUSER);
      dbms_output.put_line('PROGRAM.....= '||W_PROGRAM);
      dbms_output.put_line('OS PROCESS..= '||W_OSPROC);
      dbms_output.put_line('ROW.........= '||W_ROW);
      dbms_output.put_line('OBJECT......= '||W_OBJECT);
      dbms_output.put_line('FILE........= '||W_FILE);
      dbms_output.put_line('BLOCK.......= '||W_BLOCK);
      dbms_output.put_line('QUERY.......= '||substr(W_SQLTEXT,1,200));
      dbms_output.put_line('-------------------------------------------------------------------');

   end loop;
end;
/

=== in oracle 8i===================
col owner for a20
 col object_name for a30
SELECT LPAD(' ',DECODE(l.xidusn,0,3,0)) || l.oracle_username "User_Name",
o.owner, o.object_name, o.object_type
FROM v$locked_object l, dba_objects o
WHERE l.object_id = o.object_id
ORDER BY o.object_id, 1 desc
/

select a.sid, a.event, a.total_waits, a.time_waited, a.average_wait
from v$session_event a, v$session b
where time_waited > 0
and a.sid=b.sid
and b.username is not NULL
and a.event='enq: TX - row lock contention';

set linesize 200
set pagesize 200
col state for a10
col event for a40
select sid,event,SECONDS_IN_WAIT,state from gV$SESSION_WAIT order by 3;

OR
select event, state, count(*) from v$session_wait group by event, state order by 3 desc;


OR

select
  count(*),
       CASE WHEN state != 'WAITING' THEN 'WORKING'
            ELSE 'WAITING'
       END AS state,
       CASE WHEN state != 'WAITING' THEN 'On CPU / runqueue'
            ELSE event
       END AS sw_event
    FROM
      v$session_wait
   GROUP BY
      CASE WHEN state != 'WAITING' THEN 'WORKING'
           ELSE 'WAITING'
      END,
      CASE WHEN state != 'WAITING' THEN 'On CPU / runqueue'
           ELSE event
      END
   ORDER BY
      1 DESC, 2 DESC
   /

select EVENT,TOTAL_WAITS,TIME_WAITED,AVERAGE_WAIT from v$session_event  where EVENT like 'free%';

select sid, serial#, sql_id from gv$session where event = 'read by other session';

SELECT p1 "file#", p2 "block#", p3 "class#"
FROM v$session_wait
WHERE event = 'read by other session';  

SELECT relative_fno, owner, segment_name, segment_type
FROM dba_extents
WHERE file_id = &file
AND &block BETWEEN block_id AND block_id + blocks - 1;


/*******The following script will track the progress of long running queries :****/

select
 l.sid,l.sofar,l.totalwork,round(l.sofar/l.totalwork*100,2) "%complete", l.start_time, l.last_update_time,s.sql_text
 from   v$session_longops l, v$sql s
 where  s.hash_value=l.sql_hash_value 
and s.address=l.sql_address 
and s.child_number=0 
and l.sofar/l.totalwork * 100!=100;



select sid, serial# from gv$session where sql_id = '11turyz3fj75g';


select RESOURCE_NAME,CURRENT_UTILIZATION,LIMIT_VALUE from gv$resource_limit;

set feedback off
alter session set nls_timestamp_tz_format='DD-MON-YYYY HH24:MI:SS.ff';
set feedback on

--------------------This will show buffer hit ratio n it sud be >90%  -------------------------------

SELECT (P1.value + P2.value - P3.value) / (P1.value + P2.value)
     FROM   v$sysstat P1, v$sysstat P2, v$sysstat P3
     WHERE  P1.name = 'db block gets'                          
     AND    P2.name = 'consistent gets'
     AND    P3.name = 'physical reads';

SELECT ROUND((1-(phy.value / (cur.value + con.value)))*100,2) "Cache Hit Ratio"
  FROM v$sysstat cur, v$sysstat con, v$sysstat phy
 WHERE cur.name = 'db block gets'
   AND con.name = 'consistent gets'
   AND phy.name = 'physical reads'
/
-----------------------------------------------------------------------------------------------------


select * from v$session_wait where sid in (select sid from v$session where username = 'SYS')


select sid,serial#,username,machine,program,logon_time from v$session where username='SYS' and sid in (select sid from v$session_wait)

desc v$access

select * from v$access where owner='IMPACT2'

select * from v$session where sid=28


set linesize 200
column sid format 99999
column osuser format a10
column wait format a10
column info format a40
column action format a10
column sec format 99
column module format a20
column event format a50
column sec format 99999
column username format a15
select username,osuser,s.sid,s.sql_hash_value sqlhash,w.event,module,io.block_gets+io.consistent_gets gets,
                                    w.seconds_in_wait sec
from v$session_wait w,
     v$sess_io     io,
     v$session           s
                where  s.sid = w.sid and io.sid=w.sid and
                s.status='ACTIVE'
                and  w.event not in ('rdbms ipc message', 'pmon timer', 'smon timer')
                order by event
/


-------------

Query to identify the library cache pin wait (will list all the sessions waiting for library cache pin), can be replaced with other wait events

select
   sid, 
   event, 
   p1raw, 
   seconds_in_wait, 
   wait_time
from
   v$session_wait
where
   event = 'library cache pin'
and
   state = 'WAITING';

-- identify the blocker in library cache pin event (will list the lock holder and other waiting sessions), can be replaced with other wait events

select decode(lob.kglobtyp, 0, 'NEXT OBJECT', 1, 'INDEX', 2, 'TABLE', 3, 'CLUSTER',
                      4, 'VIEW', 5, 'SYNONYM', 6, 'SEQUENCE',
                      7, 'PROCEDURE', 8, 'FUNCTION', 9, 'PACKAGE',
                      11, 'PACKAGE BODY', 12, 'TRIGGER',
                      13, 'TYPE', 14, 'TYPE BODY',
                      19, 'TABLE PARTITION', 20, 'INDEX PARTITION', 21, 'LOB',
                      22, 'LIBRARY', 23, 'DIRECTORY', 24, 'QUEUE',
                      28, 'JAVA SOURCE', 29, 'JAVA CLASS', 30, 'JAVA RESOURCE',
                      32, 'INDEXTYPE', 33, 'OPERATOR',
                      34, 'TABLE SUBPARTITION', 35, 'INDEX SUBPARTITION',
                      40, 'LOB PARTITION', 41, 'LOB SUBPARTITION',
                      42, 'MATERIALIZED VIEW',
                      43, 'DIMENSION',
                      44, 'CONTEXT', 46, 'RULE SET', 47, 'RESOURCE PLAN',
                      48, 'CONSUMER GROUP',
                      51, 'SUBSCRIPTION', 52, 'LOCATION',
                      55, 'XML SCHEMA', 56, 'JAVA DATA',
                      57, 'SECURITY PROFILE', 59, 'RULE',
                      62, 'EVALUATION CONTEXT',
                     'UNDEFINED') object_type,
       lob.KGLNAOBJ object_name,
       pn.KGLPNMOD lock_mode_held,
       pn.KGLPNREQ lock_mode_requested,
       ses.sid,
       ses.serial#,
       ses.username
  FROM
       x$kglpn pn,
       v$session ses,
       x$kglob lob,
       v$session_wait vsw
  WHERE
   pn.KGLPNUSE = ses.saddr and
   pn.KGLPNHDL = lob.KGLHDADR
   and lob.kglhdadr = vsw.p1raw
   and vsw.event = 'library cache pin'
order by lock_mode_held desc
/

select l1.sid, ' IS BLOCKING ', l2.sid
from v$lock l1, v$lock l2
where l1.block =1 and l2.request > 0
and l1.id1=l2.id1
and l1.id2=l2.id2;
orat1r4n4sys72

625 
725


select
    s1.username || '@' || s1.machine 
    || ' ( SID,S#=' || s1.sid || ',' || s1.serial# || ' )  is blocking '
    || s2.username || '@' || s2.machine
    || ' ( SID,S#=' || s2.sid || ',' || s2.serial# || ' )'
        AS blocking_status
from
    v$lock l1,v$session s1,v$lock l2,v$session s2
where
    s1.sid = l1.sid
    and s2.sid = l2.sid
    and l1.BLOCK = 1
    and l2.request > 0
    and l1.id1 = l2.id1
    and l2.id2 = l2.id2;


TO FIND PID FROM SID ?
------------------------------
SELECT	p.program, p.spid
FROM v$session s, v$process p
WHERE s.paddr = p.addr
AND s.sid in (1057,1058);


TO FIND Session info's FROM O.S PID ?
-------------------------------------

SELECT a.sid, a.serial#, a.username, a.osuser, a.program, a.machine, a.last_call_ET, status, to_char(logon_time,'YYYY-MON-DD HH24:MI:SS') "Time logged in",module FROM v$session a, v$process b WHERE a.paddr = b.addr AND spid = '&pid';


col OBJECT_NAME format a20 
select c.owner,c.object_name,c.object_type,b.sid,b.serial#,b.status,b.osuser,b.machine from v$locked_object a,v$session b,dba_objects c where b.sid=a.session_id and a.object_id=c.object_id ;


ASH:

select SESSION_ID,NAME,P1,P2,P3,WAIT_TIME,CURRENT_OBJ#,CURRENT_FILE#,CURRENT_BLOCK# 
       from v$active_session_history ash, v$event_name enm 
       where ash.event#=enm.event# and SAMPLE_TIME>=(sysdate-300/(24*60)) and SAMPLE_TIME<=(sysdate-180/(24*60));


#############Enable trace in another session##############################

Find out SID and SERIAL# from v$session. For example:

SELECT * FROM v$session WHERE osuser = OSUSER;

to start trace:

EXECUTE dbms_support.start_trace_in_session (SID, SERIAL#);

to stop trace:

EXECUTE dbms_support.stop_trace_in_session (SID, SERIAL#);

- or -

EXECUTE dbms_system.set_sql_trace_in_session (SID, SERIAL#, TRUE);
EXECUTE dbms_system.set_sql_trace_in_session (SID, SERIAL#, FALSE);


 execute dbms_system.set_sql_trace_in_session(194,45802, FALSE);
##############################################################################

set linesize 200
set pagesize 300
col SID for 9999
col MODULE format a20 
col ACTION format a10
col USERNAME format a10
col OSUSER format a10
col PROGRAM format a25  
col MACHINE format a15




col username format a10
col osuser format a15
col program format a25  
select username,sid,serial#,osuser,program,module,machine,module,logon_time from v$SEssion where status='ACTIVE' and sid in (Select session_id from v$locked_object);


select a.session_id,a.oracle_username, a.os_user_name, b.owner "OBJECT OWNER", b.object_name,b.object_type,a.locked_mode from 
(select object_id, SESSION_ID, ORACLE_USERNAME, OS_USER_NAME, LOCKED_MODE from v$locked_object) a, 
(select object_id, owner, object_name,object_type from dba_objects where object_name like '%CUSTPRO%') b
where a.object_id=b.object_id


select sid,serial#,username,osuser,module,PROGRAM,machine,last_call_ET,status,to_char(logon_time,'YYYY-MON-DD HH24:MI:SS') "Time logged in" from v$session where sid='69';

select status,to_char(logon_time,'YYYY-MON-DD HH24:MI:SS') "Time logged in", username, machine from v$session where status != 'ACTIVE' order by logon_time desc;

select sid,serial#,username,osuser,PROGRAM,machine,last_call_ET,status,to_char(logon_time,'YYYY-MON-DD HH24:MI:SS') "Time logged in" from v$session order by logon_time desc;

select sid,serial#,machine,program,osuser,username,status,to_char(logon_time,'YYYY-MON-DD HH24:MI:SS') from v$session where status like 'INACTIVE' and username not like 'ORACLE' and logon_time < sysdate -2 order by logon_time desc;

select status,to_char(logon_time,'YYYY-MON-DD HH24:MI:SS') "Time logged in", username, machine from v$session where status like 'KILLED' order by logon_time asc;

select sid,serial#,username,osuser,PROGRAM,machine,last_call_ET,status,to_char(logon_time,'YYYY-MON-DD HH24:MI:SS') "Time logged in" from v$session where sid in (select sid from v$access where owner not in ('SYS','SYSTEM','PUBLIC','DBVISION') and object in ('BILLSUMMARY') );

KILLING SESSIONS:
----------------

alter system kill session '&a,&b';

select count(*) from v$session;

select count(*) from v$session where status<>'ACTIVE';

select count(*) from v$session where username <>'SYS';

select 'ALTER SYSTEM KILL SESSION '''||SID||','||SERIAL#||''' IMMEDIATE;' from v$session where username<>'SYS';

select 'ALTER SYSTEM KILL SESSION '''||SID||','||SERIAL#||''' IMMEDIATE'||';' FROM V$SESSION WHERE  username like 'SYS'  and program ='exp.exe';

ALTER SYSTEM KILL Session Marked for Killed Forever:
====================================================
 
You have a session that you have killed, but it seems as though it will not go away:

SQL> alter system kill session 'sid, serial#';

SQL> select status, username from v$session;

            status    killed
            username  username  

You have issued this several times and it seems it still is marked as killed.

In order to determine which process to kill:

a) On a Unix platform:

SQL> SELECT spid
                 FROM v$process
                 WHERE NOT EXISTS ( SELECT 1
                                    FROM v$session
                                    WHERE paddr = addr);

or 

SQL> SELECT inst_id, status, event, state, blocking_session, sid, serial#, program
     FROM   gv$session 
     WHERE  status = 'KILLED';

% kill <spid>

b) On a Windows platform:

SQL> SELECT spid, osuser, s.program 
                FROM v$process p, v$session s 
                WHERE p.addr=s.paddr;

Then use the orakill utility at the DOS prompt:

c:\> orakill <SID> <spid> 

where <SID>  = the Oracle instance name (ORACLE_SID)
      <spid> = the thread id of the thread to kill


orakill <SID> <spid>
orakill 147 3524


C:\Users\Impactadm>orakill IMPACT01 3524

Kill of thread id 3524 in instance IMPACT01 successfully signalled.

number of opened cursor's:
------------------------

select * from ( select ss.value, sn.name, ss.sid
 from v$sesstat ss, v$statname sn
 where ss.statistic# = sn.statistic#
 and sn.name like '%opened cursors current%'
 order by value desc) where rownum < 11 ;


RMAN enqueue lock drill down:
----------------------------

    SELECT s.sid, username AS "User", program, module, action, logon_time "Logon", l.* 
     FROM v$session s, v$enqueue_lock l
     WHERE l.sid = s.sid and l.type = 'CF' AND l.id1 = 0 and l.id2 = 2;

###############DBA_DB_LINKS################################################

Dropping a db link from another's schema :

Take backup of db link before dropping it for safer purposses by giving the below command:

SELECT DBMS_METADATA.GET_DDL(‘DB_LINK’,a.db_link,a.owner) FROM dba_db_links a;

SQL> select * from dba_db_links;

OWNER                          DB_LINK                        USERNAME                       HOST                   CREATED
------------------------------ ------------------------------ ------------------------------ ------------------------------ ---------
ELOG                           BP_ELOGBOOK                    ELOG                           abztestora20:1521/HAWKDEV1     22-MAY-13


SQL> CREATE or replace PROCEDURE ELOG.drop_db_link AS
  2  BEGIN
  3  EXECUTE IMMEDIATE 'drop DATABASE LINK BP_ELOGBOOK';
  4  END drop_db_link;
  5  /

Procedure created.

SQL> EXEC ELOG.drop_db_link;

PL/SQL procedure successfully completed.

SQL> select * from dba_db_links;

no rows selected

SQL> DROP PROCEDURE ELOG.drop_db_link;

Procedure dropped.



#########TO FIND SQL_TEXT FROM SID#####################

select sql_text,sid,username,status
from gv$session s, gv$sqlarea q
where s.sql_hash_value = q.hash_value
and s.sql_address = q.address
and s.sid = &1;



######Show locked objects###########

set lines 200 pages 999
col username 	format a20
col sess_id 	format a10
col object	format a25
col mode_held	format a20
select	oracle_username || ' (' || s.osuser || ')' username
,	s.sid || ',' || s.serial# sess_id
,	owner || '.' ||	object_name object
,	object_type
,	decode(	l.block
	,	0, 'Not Blocking'
	,	1, 'Blocking'
	,	2, 'Global') status
,	decode(v.locked_mode
	,	0, 'None'
	,	1, 'Null'
	,	2, 'Row-S (SS)'
	,	3, 'Row-X (SX)'
	,	4, 'Share'
	,	5, 'S/Row-X (SSX)'
	,	6, 'Exclusive', TO_CHAR(lmode)) mode_held
from	v$locked_object v
,	dba_objects d
,	v$lock l
,	v$session s
where 	v.object_id = d.object_id
and 	v.object_id = l.id1
and 	v.session_id = s.sid
order by oracle_username
,	session_id



##########################Automate DB Checks using Procedure#########################################

set lines 200 pages 300
set time on


prompt "Creating procedure proc_db_checks..."

CREATE OR REPLACE PROCEDURE proc_gen_output
IS
v_dbname varchar2(30);
v_spc_line varchar2(30);
v_rundate varchar2(30);
v_file utl_file.file_type;
v_line varchar2(2000);
v_line2 varchar2(2000);
v_opt_stat varchar2(2000);
v_spc_adv varchar2(2000);
v_flbk_sts varchar2(2000);
v_dest_1 varchar2(2000);
v_dest_10 varchar2(2000);
v_stat varchar2(2000);
v_lg_mde varchar2(2000);
v_rec_file varchar2(2000);
v_dir_path varchar2(2000);
v_lname varchar2(2000);
v_cname varchar2(2000);
v_filename varchar2(30);
BEGIN
select 'Database ' ||NAME INTO v_dbname from v$database;
select '' INTO v_spc_line from dual;
SELECT to_char(SYSDATE,'YYYY-MM-DD HH24:MI:SS') name INTO v_rundate from DUAL;
SELECT STATUS INTO v_opt_stat FROM DBA_AUTOTASK_OPERATION where client_name like '%auto optimizer%';
SELECT STATUS INTO v_spc_adv FROM DBA_AUTOTASK_OPERATION where client_name like '%space advisor%';
SELECT flashback_on INTO v_flbk_sts FROM V$DATABASE;
SELECT value INTO v_dest_1 FROM v$parameter where name='log_archive_dest_state_1';
SELECT value INTO v_dest_10 FROM v$parameter where name='log_archive_dest_state_10';
SELECT STATUS INTO v_stat FROM V$BLOCK_CHANGE_TRACKING;
SELECT log_mode INTO v_lg_mde from v$database;
SELECT value into v_rec_file from v$parameter where name='db_recovery_file_dest';
SELECT DIRECTORY_PATH into v_dir_path  FROM DBA_DIRECTORIES WHERE DIRECTORY_NAME='DATA_PUMP_DIR';
SELECT COUNT(MEMBER) INTO v_lname FROM V$LOGFILE where GROUP#=1;
SELECT COUNT(NAME) INTO v_cname FROM V$CONTROLFILE;
v_file := utl_file.FOPEN('DATA_PUMP_DIR','proc_gen_output.log','w');
v_line := v_dbname ||' audited at '|| v_rundate ||CHR(13) || CHR(10) || v_spc_line ||CHR(13) || CHR(10) ||'AUTO_OPTIMIZER_STATS  is '||v_opt_stat
||CHR(13) || CHR(10) ||'AUTO_SPACE_ADVISOR    is '||v_opt_stat ||CHR(13) || CHR(10) ||'FLASHBACK_ON          is '||v_flbk_sts ||CHR(13) || CHR(10) ||'LOGARC_DEST_STATE1    is '||v_dest_1
||CHR(13) || CHR(10) ||'LOGARC_DEST_STATE10   is '||v_dest_10 ||CHR(13) || CHR(10) ||'BLOCK_CHANGE_TRACKING is '||v_stat ||CHR(13) || CHR(10) ||'ARCLOG_MODE_STATUS    is '||v_lg_mde
||CHR(13) || CHR(10) ||'RECOVERY_FILEDEST     is '||v_rec_file ||CHR(13) || CHR(10) ||'DATA_PUMP_DIR-PATH    is '||v_dir_path ||CHR(13) || CHR(10) ||'REDOLOG_MULTIPLEXING  is '||v_lname
||CHR(13) || CHR(10) ||'CTRLFILE_MULTIPLEXING is '||v_cname;
utl_file.PUTF(v_file,v_line);
utl_file.fCLOSE(v_file);
END;
/



prompt "Running the procedure to perform the DB Checks...""


exec proc_gen_output;


prompt "Now Go to DATA_PUMP_DIR directory to check proc_db_checks.log file..."


################## Procedure to do table refresh and run merge statement#####################################


CREATE OR REPLACE PROCEDURE ADSL."REFRESH_GEEI_DATA"
AS
v_start_dt	DATE;
v_proc_name	VARCHAR2(40) := 'REFRESH_GEEI_DATA';
v_ins		PLS_INTEGER  := 0;
BEGIN
EXECUTE IMMEDIATE 'truncate table GEEI_PAN';

v_start_dt := SYSDATE;

insert into GEEI_PAN
select * from GEEI_PAN_V@BDMSFTTP_PROD_PUBLIC_LINK;

v_ins := SQL%ROWCOUNT;

INSERT INTO dbms_jobs_detail_stats
(job_name, start_dt, end_dt, table_name, read_count,
update_count, insert_count, data_source)
VALUES (v_proc_name, v_start_dt, SYSDATE, 'GEEI_PAN', v_ins,
0, v_ins, 'GEEI_PAN_V@BDMSFTTP_PROD_PUBLIC_LINK');

COMMIT;
v_start_dt := SYSDATE;

MERGE INTO GEEI_STAFF a
USING GEEI_STAFF_V b
ON (b.VZID=a.VZID)
WHEN MATCHED THEN
UPDATE SET
a.FULL_NAME=b.FULL_NAME,
a.FIRST_LAST=b.FIRST_LAST,
a.LAST_FIRST_METRIC=b.LAST_FIRST_METRIC,
a.EMP_TYPE=b.EMP_TYPE,
a.MGR_SUP=b.MGR_SUP,
a.WORK_LOC=b.WORK_LOC,
a.STATUS=b.STATUS,
a.DISP=b.DISP,
a.START_DATE=b.START_DATE,
a.END_DATE=b.END_DATE,
a.CONTRACTOR_CO=b.CONTRACTOR_CO,
a.VZID=b.VZID,
a.FORECAST_END_DT=b.FORECAST_END_DT,
a.NOTES=b.NOTES,
a.UPDATED_BY=b.UPDATED_BY,
a.UPDATED_DT=b.UPDATED_DT
WHEN NOT MATCHED THEN
INSERT
(
FULL_NAME,
FIRST_LAST,
LAST_FIRST_METRIC,
EMP_TYPE,
MGR_SUP,
WORK_LOC,
STATUS,
DISP,
START_DATE,
END_DATE,
CONTRACTOR_CO,
VZID,
FORECAST_END_DT,
NOTES,
UPDATED_BY,
UPDATED_DT
)
VALUES
(
b.FULL_NAME,
b.FIRST_LAST,
b.LAST_FIRST_METRIC,
b.EMP_TYPE,
b.MGR_SUP,
b.WORK_LOC,
b.STATUS,
b.DISP,
b.START_DATE,
b.END_DATE,
b.CONTRACTOR_CO,
b.VZID,
b.FORECAST_END_DT,
b.NOTES,
b.UPDATED_BY,
b.UPDATED_DT
);

v_ins := SQL%ROWCOUNT;

INSERT INTO dbms_jobs_detail_stats
(job_name, start_dt, end_dt, table_name, read_count,
update_count, insert_count, data_source)
VALUES (v_proc_name, v_start_dt, SYSDATE, 'GEEI_STAFF', v_ins,
, v_ins, 0, 'GEEI_STAFF_V');

COMMIT;
END;


################### To run table stats in INCR mode through a procedure using a cursor#############################

To Create the procedure :
------------------------

CREATE OR REPLACE PROCEDURE GATHER_TABLE_STATS_INCR IS
stmnt1 varchar2(1000);
cnt NUMBER;
CURSOR c_Cl IS 
SELECT a.owner owner,
a.table_name table_name,
a.status,
a.num_rows,
a.last_analyzed,
a.sample_size,
a.partitioned,
b.inserts + b.updates + b.deletes AS total_dml_since_stats,
b.timestamp,
( (b.inserts + b.updates + b.deletes) / a.num_rows) * 100 percent_change
FROM dba_tables a, dba_tab_modifications b
WHERE a.owner IN ('WFM_NT') AND a.partitioned = 'NO'
and a.owner = b.table_owner
and a .table_name = b.table_name
and a.num_rows <> 0;
BEGIN
FOR tab_rec IN c_Cl
LOOP
cnt:=0;
DBMS_OUTPUT.PUT_LINE('checking OWNER: '||tab_rec.owner);
DBMS_OUTPUT.PUT_LINE('checking TAB: '||tab_rec.table_name);
execute immediate 'SELECT COUNT(*) FROM ' ||tab_rec.owner || '.' || tab_rec.table_name INTO cnt;
if cnt>2 then
stmnt1:='BEGIN
dbms_stats.gather_table_stats
(ownname           =>'''||tab_rec.owner||''',
 tabname           =>'''||tab_rec.table_name||''',
 estimate_percent =>NULL,
 method_opt	   =>FOR ALL INDEXED COLUMNS SIZE 1,
 no_invalidate	   =>FALSE,
 cascade	   =>true,
 degree		   =>8);
end;';
dbms_output.put_line (stmnt1);
execute immediate stmnt1;
end if;
cnt:=0;
END LOOP;
EXCEPTION
WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('An error was encountered-'||SQLCODE||'-ERROR-'||SQLERRM||''||stmnt1);
END;
/


To run the procedure :
---------------------

set serverout on;

exec GATHER_TABLE_STATS_INCR;


###############To fetch SQL Query output inta a .xls file using a procedure########################

CREATE OR REPLACE PROCEDURE export_cities(dir VARCHAR2, file_name VARCHAR2) 
  IS
    CURSOR cur IS SELECT name || ',' || state AS row_value FROM cities;
    file UTL_FILE.FILE_TYPE;
  BEGIN  
      -- Open the file for writing
    file := UTL_FILE.FOPEN(UPPER(dir), file_name, 'w', 32767);
 
    -- Export rows one by one 
    FOR rec IN cur LOOP 
       -- All columns were concatenated into single value in SELECT
       UTL_FILE.PUT_LINE(file, rec.row_value);
    END LOOP;
 
     UTL_FILE.FCLOSE(file);
  END;
  /

CALL export_cities('exportdir', 'cities2.csv');

(OR)

CREATE OR REPLACE PROCEDURE PRM83QA.proc_daily_alert_qa(dir VARCHAR2, file_name VARCHAR2) 
IS
select_stmt VARCHAR2(2000) := 'SELECT sw.SD_UAN || '','' || sw.SD_PRI_ACCT_NUM || '','' || sw.DD_TRAN_DAT_TIM || '','' ||
dar.BD_ALERTEDRULE || '','' || dar.SD_RULES || '','' || sw.SD_TERM_NAME_LOC || '','' || sw.SD_TERM_CITY || '','' ||
sw.SD_TERM_ST || '','' || sw.MD_TRAN_AMT1 || '','' || sw.SD_RETL_SIC_CDE
FROM PRM83QA.SHORTWINDOW sw JOIN PRM83QA.DETAIL_ALERTED_RULE dar
ON sw.SD_TIEBREAKER=dar.SD_TIEBREAKER
WHERE dar.DD_PARTITION_DATE >= (SYSDATE-1)
AND dar.DD_PARTITION_DATE < SYSDATE
AND dar.SD_RULES NOT IN (''.1520.'' || '','' || ''.1202.'' || '','' || ''.1458'')';
cur INTEGER;
file UTL_FILE.FILE_TYPE;
row_value VARCHAR2(4000);
ret INTEGER;
BEGIN
-- Open a cursor for the specified SELECT statement
cur := DBMS_SQL.OPEN_CURSOR;
DBMS_SQL.PARSE(cur, select_stmt, DBMS_SQL.NATIVE);
ret := DBMS_SQL.EXECUTE(cur);
 
-- All columns were concatenated into single value in SELECT
DBMS_SQL.DEFINE_COLUMN(cur, 1, row_value, 4000);
 
-- Open the file for writing
file := UTL_FILE.FOPEN(UPPER(dir),file_name,'w', 32767);
 
-- Export rows one by one 
LOOP
ret := DBMS_SQL.FETCH_ROWS(cur);       
EXIT WHEN ret = 0;
 
-- Get the value 
row_value := NULL;
DBMS_SQL.COLUMN_VALUE(cur, 1, row_value);
 
-- Write the row to the file
UTL_FILE.PUT_LINE(file, row_value);  
END LOOP;
 
UTL_FILE.FCLOSE(file);
DBMS_SQL.CLOSE_CURSOR(cur);     
END;
/



exec proc_daily_alert_rpt('DATA_PUMP_DIR', 'daily_report.xls');


#################To fetch SQL query output into a .xls file with good format ##########################


SQL> SET PAGESIZE 40000

SQL> SET FEEDBACK OFF

SQL> SET MARKUP HTML ON

SQL> SET NUM 24

SQL> SPOOL ora_htl_hist.xls

SQL>

SQL>SELECT COUNT * FROM ORA.HTL_HIST;

SQL>

SQL>SPOOL OFF

SQL>SET MARKUP HTML OFF

SQL>SPOOL OFF


###################To insert existing users,roles,privileges into separate tables using PL\SQL Block##############

create table table1
( dbname varchar(2000),
  username varchar(2000));


create table table2
( dbname varchar(2000),
  role varchar(2000));


create table table3
( dbname varchar(2000),
  grantee varchar(2000),
  granted_role varchar(2000));

create table table4
( dbname varchar(2000),
  grantee varchar(2000),
  privilege varchar(2000));


declare 
v_name v$database.name%TYPE;
BEGIN
select name into v_name from v$database;
insert into table1 select v_name, USERNAME from dba_users;
insert into table2 select v_name, ROLE from dba_roles;
insert into table3 select v_name, GRANTEE, GRANTED_ROLE from dba_role_privs;
insert into table4 select v_name, GRANTEE, privilege from dba_sys_privs;
END;
/


############################## Busy Buffer Waits ? ##################################

select substr(event,1,25)"Event",Total_waits, Total_timeouts,Time_waited,Average_wait from v$system_event where event='buffer busy waits';

desc v$system_event;

select event from v$system_event;

select * from v$waitstat where class ='data block';


#######################################################################################

SELECT DECODE(request,0,'Holder: ','Waiter: ')||sid sess,
         id1, id2, lmode, request, type, ctime
    FROM V$LOCK WHERE (id1, id2, type) IN
             (SELECT id1, id2, type FROM V$LOCK WHERE request>0)
   ORDER BY id1, request;


SELECT s.sid,
        waiter.p1raw w_p1r,
        waiter.p2raw w_p2r,
        holder.event h_wait,
        holder.p1raw h_p1r,
        holder.p2raw h_p2r,
        count(s.sid) users_blocked,
        sql.hash_value
    FROM
       v$sql sql,
       v$session s,
       x$kgllk l,
       v$session_wait waiter,
       v$session_wait holder
   WHERE
       s.sql_hash_value = sql.hash_value and
       l.KGLLKADR=waiter.p2raw and
       s.saddr=l.kgllkuse and
       waiter.event like 'library cache lock' and
       holder.sid=s.sid
   GROUP BY
       s.sid,
       waiter.p1raw ,
       waiter.p2raw ,
       holder.event ,
       holder.p1raw ,
       holder.p2raw ,
       sql.hash_value
   ;


##########Show which row is locked###################

select	do.object_name
,	row_wait_obj#
,	row_wait_file#
,	row_wait_block#
,	row_wait_row#
,	dbms_rowid.rowid_create (1, ROW_WAIT_OBJ#, ROW_WAIT_FILE#, 
				ROW_WAIT_BLOCK#, ROW_WAIT_ROW#)
from	v$session s
,	dba_objects do
where	sid=&sid
and 	s.ROW_WAIT_OBJ# = do.OBJECT_ID
/


#########Then select the row with that rowid...#############

select * from <table> where rowid=<rowid>;

##########List locks################

column lock_type format a12
column mode_held format a10
column mode_requested format a10
column blocking_others format a20
column username format a10
SELECT	session_id
,	lock_type
,	mode_held
,	mode_requested
,	blocking_others
,	lock_id1
FROM	dba_lock l
WHERE 	lock_type NOT IN ('Media Recovery', 'Redo Thread')
/


select max(sequence#),thread# from v$archived_log where COMPLETION_TIME < sysdate -2 group by thread#

Now convert each set of three digits to a single digit using this table:
Binary	Becomes
000	0
001	1
010	2
011	3
	
Binary	Becomes
100	4
101	5
110	6
111	7


The following query shows a count of and the size of the redo log files by day (for a single instance).

SELECT A.*,Round(A.Count#*B.AVG#/1024/1024/1024) Daily_Avg_GB FROM
(SELECT To_Char(First_Time,'YYYY-MM-DD') DAY,Count(1) Count#,Min(RECID) Min#,Max(RECID) Max#
FROM v$log_history 
GROUP BY To_Char(First_Time,'YYYY-MM-DD')
ORDER BY 1 DESC) A,
(SELECT Avg(BYTES) AVG#,Count(1) Count#,Max(BYTES) Max_Bytes,Min(BYTES) Min_Bytes
FROM v$log) B


SELECT A.*,Round(A.Count#*B.AVG#/1024/1024) Daily_Avg_MB FROM
(SELECT To_Char(First_Time,'YYYY-MM-DD') DAY,Count(1) Count#,Min(RECID) Min#,Max(RECID) Max#
FROM v$log_history 
GROUP BY To_Char(First_Time,'YYYY-MM-DD')
ORDER BY 1 DESC) A,
(SELECT Avg(BYTES) AVG#,Count(1) Count#,Max(BYTES) Max_Bytes,Min(BYTES) Min_Bytes
FROM v$log) B


#############

Thread 1 cannot allocate new log, sequence 517
Private strand flush not complete

set linesize 100;
col member format a50;
select l.group#, lf.member, l.bytes/1024/1024 mb,  l.status, l.archived
from v$logfile lf, v$log l
where l.group# = lf.group#
order by 1, 2;

#################################
GEneral not validated scripts"

rem -----------------------------------------------------------------------
rem Purpose:    Shows active (in progress) transactions
rem -----------------------------------------------------------------------

col name format a8
col username format a8
col osuser format a8
col start_time format a17
col status format a12
tti 'Active transactions'

select username, terminal, osuser,
       t.start_time, r.name, t.used_ublk "ROLLB BLKS",
       decode(t.space, 'YES', 'SPACE TX',
          decode(t.recursive, 'YES', 'RECURSIVE TX',
             decode(t.noundo, 'YES', 'NO UNDO TX', t.status)
       )) status
from sys.v_$transaction t, sys.v_$rollname r, sys.v_$session s
where t.xidusn = r.usn
  and t.ses_addr = s.saddr
/
rem -----------------------------------------------------------------------
rem Purpose:    Shows active (in progress) transactions
rem -----------------------------------------------------------------------

col name format a8
col username format a8
col osuser format a8
col start_time format a17
col status format a12
tti 'Active transactions'

select username, terminal, osuser,
       t.start_time, r.name, t.used_ublk "ROLLB BLKS",
       decode(t.space, 'YES', 'SPACE TX',
          decode(t.recursive, 'YES', 'RECURSIVE TX',
             decode(t.noundo, 'YES', 'NO UNDO TX', t.status)
       )) status
from sys.v_$transaction t, sys.v_$rollname r, sys.v_$session s
where t.xidusn = r.usn
  and t.ses_addr = s.saddr
/

rem--------------------------------------------------------------------------
rem Purpose:	Displays information on all active database sessions.
rem-----------------------------------------------------------------------------
SET LINESIZE 500
SET PAGESIZE 1000

COLUMN username FORMAT A15
COLUMN machine FORMAT A25
COLUMN logon_time FORMAT A20

SELECT NVL(s.username, '(oracle)') AS username,
       s.osuser,
       s.sid,
       s.serial#,
       p.spid,
       s.lockwait,
       s.status,
       s.module,
       s.machine,
       s.program,
       TO_CHAR(s.logon_Time,'DD-MON-YYYY HH24:MI:SS') AS logon_time
FROM   v$session s,
       v$process p
WHERE  s.paddr  = p.addr
AND    s.status = 'ACTIVE'
ORDER BY s.username, s.osuser;

7250853861

rem--------------------------------------------------------------------------
rem:	Displays I/O information on all database sessions.
rem-----------------------------------------------------------------------------
SET LINESIZE 500
SET PAGESIZE 1000

COLUMN username FORMAT A15

SELECT NVL(s.username, '(oracle)') AS username,
       s.osuser,
       s.sid,
       s.serial#,
       si.block_gets,
       si.consistent_gets,
       si.physical_reads,
       si.block_changes,
       si.consistent_changes
FROM   v$session s,
       v$sess_io si
WHERE  s.sid = si.sid
ORDER BY s.username, s.osuser;

SET PAGESIZE 14

------------------------------------------------------------------------
rem:	Displays information on all long operations.
rem---------------------------------------------------------------------

COLUMN sid FORMAT 999
COLUMN serial# FORMAT 9999999
COLUMN machine FORMAT A30
COLUMN progress_pct FORMAT 99999999.00
COLUMN elapsed FORMAT A10
COLUMN remaining FORMAT A10

SELECT s.sid,
       s.serial#,
       s.machine,
       TRUNC(sl.elapsed_seconds/60) || ':' || MOD(sl.elapsed_seconds,60) elapsed,
       TRUNC(sl.time_remaining/60) || ':' || MOD(sl.time_remaining,60) remaining,
       ROUND(sl.sofar/sl.totalwork*100, 2) progress_pct
FROM   v$session s,
       v$session_longops sl
WHERE  s.sid     = sl.sid
AND    s.serial# = sl.serial#;

rem--------------------------------------------------------------------------
rem Purpose:	Displays a list of SQL statements that are using the most 
		resources.
rem--------------------------------------------------------------------------
SET LINESIZE 500
SET PAGESIZE 1000
SET VERIFY OFF

SELECT *
FROM   (SELECT Substr(a.sql_text,1,50) sql_text,
               Trunc(a.disk_reads/Decode(a.executions,0,1,a.executions)) reads_per_execution, 
               a.buffer_gets, 
               a.disk_reads, 
               a.executions, 
               a.sorts,
               a.address
        FROM   v$sqlarea a
        ORDER BY 2 DESC)
WHERE  rownum <= &&1;





set linesize 150
col module for a35
col program for a35

select sid,status,action,module,program,to_char(LOGON_TIME,'dd-mm-yyyy:HH24:mi') from v$session where sid in ( select distinct sid from v$session_longops);


rem--------------------------------------------------------------------------------
rem Purpose:	To add a datafile in primay and Standby site.
rem--------------------------------------------------------------------------------
Primary:
alter tablespace TRANS_DATA_01 add datafile 'K:\ORP049\P049_08\TRANS_DATA_01_09.DBF' size 1000M;
Standby:
alter database mount standby database;

alter database create datafile 'K:\ORP049\P049_08\TRANS_DATA_01_09.DBF' as 'K:\ORP049\P049_08\TRANS_DATA_01_09.DBF';
ET ECHO off 
REM NAME:   TFSDBJRN.SQL 
REM USAGE:"@path/tfsdbjrn" 
REM ------------------------------------------------------------------------ 
REM REQUIREMENTS: 
REM    SELECT on DBA_JOBS, DBA_JOBS_RUNNING 
REM ------------------------------------------------------------------------ 
REM PURPOSE: 
REM    Lists all jobs that are currently running in the local databbase. 
REM    This lists only the jobs submitted via DBMS_JOB
REM ------------------------------------------------------------------------ 
REM Main text of script follows: 
 
set pagesize 80 
title - 
  center  'List Running Jobs'  skip 2 
 
col sess format 99   heading 'Ses' 
col jid  format 999  heading 'Id' 
col subu format a10  heading 'Submitter'     trunc 
col secd format a10  heading 'Security'      trunc 
col proc format a20  heading 'Job'           word_wrapped 
col lsd  format a5   heading 'Last|Ok|Date'  
col lst  format a5   heading 'Last|Ok|Time' 
col nrd  format a5   heading 'This|Run|Date' 
col nrt  format a5   heading 'This|Run|Time' 
col fail format 99 heading 'Err' 
 
select 
  djr.sid                        sess, 
  djr.job                        jid, 
  dj.log_user                    subu, 
  dj.priv_user                   secd, 
  dj.what                        proc, 
  to_char(djr.last_date,'MM/DD') lsd, 
  substr(djr.last_sec,1,5)       lst, 
  to_char(djr.this_date,'MM/DD') nrd, 
  substr(djr.this_sec,1,5)       nrt, 
  djr.failures                   fail 
from 
  sys.dba_jobs dj, 
  sys.dba_jobs_running djr 
where 
  djr.job = dj.job 
/ 

########## Online redo log size advisory #############
SELECT TARGET_MTTR,ESTIMATED_MTTR,WRITES_MTTR,WRITES_LOGFILE_SIZE, OPTIMAL_LOGFILE_SIZE FROM V$INSTANCE_RECOVERY;

##########################lock holder info ###############
col holder format a25
col waiter format a25
select distinct o.object_name, sh.username||'('||sh.sid||')' "Holder", sw.username||'('||sw.sid||')' "Waiter",
        decode(lh.lmode, 1, 'null', 2, 
              'row share', 3, 'row exclusive', 4,  'share', 
              5, 'share row exclusive' , 6, 'exclusive')  "Lock Type"
  from all_objects o, v$session sw, v$lock lw, v$session sh, v$lock lh
 where lh.id1  = o.object_id
  and  lh.id1  = lw.id1
  and  sh.sid  = lh.sid
  and  sw.sid  = lw.sid
  and  sh.lockwait is null
  and  sw.lockwait is not null
  and  lh.type = 'TM'
  and  lw.type = 'TM'
/




   1.  View currently active UNDO usage
   2. Using current undo usage figures, estimate percentage of UNDO required based on UNDO_RETENTION

SELECT (used_ublk * (SELECT block_size
                                    FROM dba_tablespaces
                                    WHERE contents = 'UNDO'))/1024/1024 MB
FROM v$transaction; 
################
SELECT ROUND(((ur * (ups * dbs)) + (dbs * 24))/ut*100,0) AS "%"
FROM (SELECT VALUE AS ur
           FROM v$parameter
           WHERE NAME = 'undo_retention'),
                (SELECT (SUM (undoblks) / SUM (((end_time - begin_time) * 25200))
                ) AS ups
                 FROM v$undostat),
                     (SELECT block_size AS dbs
                      FROM dba_tablespaces
                      WHERE tablespace_name = (SELECT VALUE
                                                                    FROM v$parameter
                                                                    WHERE NAME = 'undo_tablespace')),
                     (SELECT sum(bytes) as ut
                      FROM dba_data_files
                      WHERE tablespace_name = (SELECT VALUE
                                                                    FROM v$parameter
                                                                    WHERE NAME = 'undo_tablespace'));

   ############## monitoring temp space in oracle#####
   SELECT ROUND(SUM( u.blocks * blk.block_size)/1024/1024,0)
FROM v$sort_usage u,
     (SELECT block_size
     FROM dba_tablespaces
     WHERE contents = 'TEMPORARY') blk;

====================
     SELECT   A.tablespace_name tablespace, D.mb_total,
         SUM (A.used_blocks * D.block_size) / 1024 / 1024 mb_used,
         D.mb_total - SUM (A.used_blocks * D.block_size) / 1024 / 1024 mb_free
FROM     v$sort_segment A,
         (
         SELECT   B.name, C.block_size, SUM (C.bytes) / 1024 / 1024 mb_total
         FROM     v$tablespace B, v$tempfile C
         WHERE    B.ts#= C.ts#
         GROUP BY B.name, C.block_size
         ) D
WHERE    A.tablespace_name = D.name
GROUP by A.tablespace_name, D.mb_total;

================
SELECT s.sid "SID",s.username "User",s.program "Program", u.tablespace "Tablespace",
u.contents "Contents", u.extents "Extents", u.blocks*8/1024 "Used Space in MB", q.sql_text "SQL TEXT",
a.object "Object", k.bytes/1024/1024 "Temp File Size"
FROM v$session s, v$sort_usage u, v$access a, dba_temp_files k, v$sql q
WHERE s.saddr=u.session_addr
and s.sql_address=q.address
and s.sid=a.sid
and u.tablespace=k.tablespace_name;
===============

select sum( u.blocks * blk.block_size)/1024/1024 "Mb. in sort segments"
, (hwm.max * blk.block_size)/1024/1024 "Mb. High Water Mark"
from v$sort_usage u, (select block_size
from dba_tablespaces
where contents = 'TEMPORARY') blk
, (select segblk#+blocks max
from v$sort_usage
where segblk# = (select max(segblk#) from v$sort_usage) ) hwm
group by hwm.max * blk.block_size/1024/1024;


############### SGA & PGA ###################################

To determine the amount of memory remaining in the shared pool:

    Select s.name, s.bytes "Free Bytes",
    Round((s.bytes/p.value)*100,2) "Perc Free",
    p.value / (1024 * 1024) "SP Size MB"
    from sys.v_$parameter p, sys.v_$sgastat s
    where s.name = 'free memory'
    and p.name = 'shared_pool_size';

This shows the total free space remaining in the shared pool, the percentage free and the total space. 
Alternately, the following shows how memory is being used in the shared pool:

    select pool, name, sum(bytes) from v$sgastat
    where pool like '%pool%'
    group by rollup (pool, name);


select POOL, round(bytes/1024/1024,0) FREE_MB
from v$sgastat
where name like '%free memory%';



select pool, sum(bytes) from v$sgastat 
where pool is not null 
group by pool 
order by pool;


REM  Locate the top PGA user

set lines 75
set pages 999
set serveroutput on

spool topuser.out

select * from gv$version;

declare a1 number;
            a2 number;
            a3 varchar2(30);
            a4 varchar2(30);
            a5 number;
            a6 number;
            a7 number;
            a8 number;
            blankline varchar2(70);

cursor code is select pid, spid, substr(username,1,20) "USER" , substr(program,1,30) "Program",
PGA_USED_MEM, PGA_ALLOC_MEM, PGA_FREEABLE_MEM, PGA_MAX_MEM
from v$process where pga_alloc_mem=
(select max(pga_alloc_mem) from v$process
where program not like '%LGWR%');

begin
  blankline:=chr(13);
  open code;
  fetch code into a1, a2, a3, a4, a5, a6, a7, a8;

  dbms_output.put_line(blankline);
  dbms_output.put_line('               Top PGA User');
  dbms_output.put_line(blankline);

  dbms_output.put_line('PID:   '||a1||'             '||'SPID:   '||a2);
  dbms_output.put_line('User Info:           '||a3);
  dbms_output.put_line('Program:            '||a4);
  dbms_output.put_line('PGA Used:            '||a5);
  dbms_output.put_line('PGA Allocated:        '||a6);
  dbms_output.put_line('PGA Freeable:             '||a7);
  dbms_output.put_line('Maximum PGA:            '||a8);

end;
/  

set lines 132
col value format 999,999,999,999,999

select * from v$pgastat;

spool off

REM
REM  Investigate memory from the database side
REM

col TTL format 999,999,999,999 heading "Total Memory"

break on report
compute sum on report of TTL

select bytes TTL from v$sgainfo where name='Maximum SGA Size'
union
select value from v$pgastat where name='total PGA allocated'
/

set lines 132
set pages 999

spool workareaoverview.out

REM overview of PGA usage

col name format a40 head "Name"
col value format 999,999,999 head "Total"
col unit format a10 head "Units"
col pga_size format a25 head "PGA Size"
col optimal_executions format 999,999,999,999 head "Optimal"
col onepass_executions format 999,999,999,999 head "One-Pass"
col multipasses_executions format 999,999,999,999 head "Multi-Pass"
col optimal_count format 999,999,999,999 head "Optimal Count"
col optimal_perc format 999 head "Optimal|PCT"
col onepass_count format 999,999,999,999 head "One-Pass Count"
col onepass_perc format 999 head "One|PCT"
col multipass_count format 999,999,999,999 head "Multi-Pass Count"
col multipass_perc format 999 head "Multi|PCT"

col sid format 999,999 Head "SID"
col operation format a30 head "Operation"
col esize format 999,999,999 head "Expected Size"
col mem format 999,999,999 head "Actual Mem"
col "MAX MEM" format 999,999,999 head "Maximum Mem"
col pass format 999,999 head "Passes"
col tsize format 999,999,999,999,999 head "Temporary|Segment Size"

spool workareaoverview.out

SELECT  name,  decode(unit, 'bytes', trunc(value/1024/1024), value) value ,
decode(unit, 'bytes', 'MBytes', unit) unit FROM V$PGASTAT
/

REM Review workarea buckets to see how efficient memory is utilized
REM  Ideal to see OPTIMAL EXECUTIONS vs. ONE-PASS and Multi-PASS

select case when low_optimal_size < 1024*1024
then to_char(low_optimal_size/1024,'999999') || 'kb  0
order by low_optimal_size
/

REM Review workarea buckets as percentages overall
REM      this script assuming 64K optimal size 

SELECT optimal_count, round(optimal_count*100/total, 2) optimal_perc,
       onepass_count, round(onepass_count*100/total, 2) onepass_perc,
       multipass_count, round(multipass_count*100/total, 2) multipass_perc
FROM
       (SELECT decode(sum(total_executions), 0, 1, sum(total_executions)) total,
               sum(OPTIMAL_EXECUTIONS) optimal_count,
               sum(ONEPASS_EXECUTIONS) onepass_count,
               sum(MULTIPASSES_EXECUTIONS) multipass_count
        FROM   v$sql_workarea_histogram
        WHERE  low_optimal_size > 64*1024)
/

REM   Review current activity in Work Areas

SELECT to_number(decode(SID, 65535, NULL, SID)) sid,
       operation_type OPERATION,trunc(EXPECTED_SIZE/1024) ESIZE,
       trunc(ACTUAL_MEM_USED/1024) MEM, trunc(MAX_MEM_USED/1024) "MAX MEM",
       NUMBER_PASSES PASS, trunc(TEMPSEG_SIZE/1024) TSIZE
FROM V$SQL_WORKAREA_ACTIVE
ORDER BY 1,2
/

alter session set NLS_DATE_FORMAT='DD-MON-YYYY HH24:MI:SS';
select sysdate from dual;

select * from v$pgastat;

col time form a30
col name form a30
select a.BEGIN_INTERVAL_TIME time, b.*
from DBA_HIST_SNAPSHOT a, DBA_HIST_PGASTAT b
where a.SNAP_ID=b.SNAP_ID
and b.name='total PGA allocated'
order by a.BEGIN_INTERVAL_TIME desc
/

show parameter parallel_execution_message_size

show parameter memory

show parameter pga

spool off
clear col


######## Tuning script at sesssion level ##########

set linesize 200
column sid format 99999
column osuser format a10
column wait format a10
column info format a40
column action format a10
column sec format 99
column module format a20
column event format a50
column sec format 99999
column username format a15
select username,osuser,s.sid,s.sql_hash_value sqlhash,w.event,module,io.block_gets+io.consistent_gets gets,
                                    w.seconds_in_wait sec
from v$session_wait w,
     v$sess_io     io,
     v$session           s
                where  s.sid = w.sid and io.sid=w.sid and
                s.status='ACTIVE'
                and  w.event not in ('rdbms ipc message', 'pmon timer', 'smon timer')
                order by event
/


-------------

Query to identify the library cache pin wait (will list all the sessions waiting for library cache pin), can be replaced with other wait events

select
   sid, 
   event, 
   p1raw, 
   seconds_in_wait, 
   wait_time
from
   v$session_wait
where
   event = 'library cache pin'
and
   state = 'WAITING';

-- identify the blocker in library cache pin event (will list the lock holder and other waiting sessions), can be replaced with other wait events

select decode(lob.kglobtyp, 0, 'NEXT OBJECT', 1, 'INDEX', 2, 'TABLE', 3, 'CLUSTER',
                      4, 'VIEW', 5, 'SYNONYM', 6, 'SEQUENCE',
                      7, 'PROCEDURE', 8, 'FUNCTION', 9, 'PACKAGE',
                      11, 'PACKAGE BODY', 12, 'TRIGGER',
                      13, 'TYPE', 14, 'TYPE BODY',
                      19, 'TABLE PARTITION', 20, 'INDEX PARTITION', 21, 'LOB',
                      22, 'LIBRARY', 23, 'DIRECTORY', 24, 'QUEUE',
                      28, 'JAVA SOURCE', 29, 'JAVA CLASS', 30, 'JAVA RESOURCE',
                      32, 'INDEXTYPE', 33, 'OPERATOR',
                      34, 'TABLE SUBPARTITION', 35, 'INDEX SUBPARTITION',
                      40, 'LOB PARTITION', 41, 'LOB SUBPARTITION',
                      42, 'MATERIALIZED VIEW',
                      43, 'DIMENSION',
                      44, 'CONTEXT', 46, 'RULE SET', 47, 'RESOURCE PLAN',
                      48, 'CONSUMER GROUP',
                      51, 'SUBSCRIPTION', 52, 'LOCATION',
                      55, 'XML SCHEMA', 56, 'JAVA DATA',
                      57, 'SECURITY PROFILE', 59, 'RULE',
                      62, 'EVALUATION CONTEXT',
                     'UNDEFINED') object_type,
       lob.KGLNAOBJ object_name,
       pn.KGLPNMOD lock_mode_held,
       pn.KGLPNREQ lock_mode_requested,
       ses.sid,
       ses.serial#,
       ses.username
  FROM
       x$kglpn pn,
       v$session ses,
       x$kglob lob,
       v$session_wait vsw
  WHERE
   pn.KGLPNUSE = ses.saddr and
   pn.KGLPNHDL = lob.KGLHDADR
   and lob.kglhdadr = vsw.p1raw
   and vsw.event = 'library cache pin'
order by lock_mode_held desc
/

##############################JOBS############################

If a job returns an error while Oracle is attempting to execute it, Oracle tries to execute it again. The first attempt is made after one minute, the second attempt after two minutes, the third after four minutes, and so on, with the interval doubling between each attempt. If the job fails 16 times, Oracle automatically marks the job as broken and no longer tries to execute it. However, between attempts, you have the opportunity to correct the problem that is preventing the job from running. This will not disturb the retry cycle, and Oracle will eventually attempt to run the job again.

SELECT owner, program_name, enabled FROM dba_scheduler_programs;


select job,what,to_char(last_date,'YYYY-MON-DD HH24:MI:SS'),to_char(next_date,'YYYY-MON-DD HH24:MI:SS'),failures,broken from dba_jobs;

desc dba_scheduler_schedules;

col OWNER for a10
col JOB_NAME for a20
col ENABLED for a8
col PROGRAM_NAME for a20
col LAST_START_DATE for a25
col LAST_RUN_DURATION for a25
col NEXT_RUN_DATE for a25
SELECT owner, job_name, enabled, PROGRAM_NAME , STATE, LAST_START_DATE, LAST_RUN_DURATION, NEXT_RUN_DATE FROM dba_scheduler_jobs;

column owner format a10
column job_name format a30
column operation format a10
column status format a10
column log_date format a27
select
   owner,
   job_name,
   operation,
   status,
   log_date
from
   dba_scheduler_job_log
where
   job_name = decode(upper('&1'), 'ALL', job_name, upper('&1'))
order by
   log_date
;

Check session where currently runing jobs:
-----------------------------------------

select j.sid,
s.spid,
s.serial#,
j.log_user,
j.job,
j.broken,
j.failures,
j.last_date||':'||j.last_sec last_date,
j.this_date||':'||j.this_sec this_date,
j.next_date||':'||j.next_sec next_date,
j.next_date - j.last_date interval,
j.what
from (select djr.SID, 
dj.LOG_USER, dj.JOB, dj.BROKEN, dj.FAILURES, 
dj.LAST_DATE, dj.LAST_SEC, dj.THIS_DATE, dj.THIS_SEC, 
dj.NEXT_DATE, dj.NEXT_SEC, dj.INTERVAL, dj.WHAT
from dba_jobs dj, dba_jobs_running djr
where dj.job = djr.job ) j,
(select p.spid, s.sid, s.serial#
from v$process p, v$session s
where p.addr = s.paddr ) s
where j.sid = s.sid;

set linesize 200
set pagesize 200
col status for a30
col job_name for a30

SELECT to_char(log_date, 'DD-MON-YY HH24:MM:SS') TIMESTAMP, job_name, status,error#,
     SUBSTR(additional_info, 1, 40) ADDITIONAL_INFO
     FROM dba_scheduler_job_run_details where log_date > sysdate-1 ORDER BY log_date;


SELECT to_char(log_date, 'DD-MON-YY HH24:MM:SS') TIMESTAMP, job_name, status,error#,
     SUBSTR(additional_info, 1, 40) ADDITIONAL_INFO
     FROM dba_scheduler_job_run_details where status <> 'SUCCEEDED';

SQL> SELECT to_char(log_date, 'DD-MON-YY HH24:MM:SS') TIMESTAMP, job_name, status,error#,
     SUBSTR(additional_info, 1, 40) ADDITIONAL_INFO
     FROM dba_scheduler_job_run_details where status <> 'SUCCEEDED';

#########

Replication check :

Team,

  Don’t ever ask operation to mark the job as success until unless if we have valid reason. If the data is heavy, let the job run and monitor the pending records and temp usage,

Execute in PDBK0
select s.snapid, r.name, r.snapshot_site, to_char(s.SNAPTIME,'YYYY-MM-DD HH24:MI:SS') last_refresh,
       count(0) rws
from   sys.slog$ s, dba_registered_snapshots r, pdbk0.mlog$_str_rtl_ut m
where  s.mowner = upper('&owner')
and    s.master = upper('&master')
and    s.snapid   = r.snapshot_id
and    s.snaptime < m.snaptime$$
group by s.snapid, r.name, r.snapshot_site, s.snaptime;

Execute in DNC(p69)

select  CURRMVOWNER_KNSTMVR || '.' || CURRMVNAME_KNSTMVR "MVIEW BEING REFRESHED",
        decode( REFTYPE_KNSTMVR, 1, 'FAST', 2, 'COMPLETE', 'UNKNOWN' ) REFTYPE,
        decode(GROUPSTATE_KNSTMVR, 1, 'SETUP', 2, 'INSTANTIATE', 3, 'WRAPUP', 'UNKNOWN' ) STATE,
        TOTAL_INSERTS_KNSTMVR INSERTS, TOTAL_UPDATES_KNSTMVR UPDATES,
        TOTAL_DELETES_KNSTMVR DELETES
   from X$KNSTMVR X WHERE type_knst=6
     and exists (select 1 from v$session s where s.sid=x.sid_knst and s.serial#=x.serial_knst);



#######

bmc query 'Submit Date' > "3/17/2010 8:00:00 AM" AND 'Submit Date' < "3/18/2010 8:00:00 AM"

( 'Submit Date' <= "3/18/2010 8:30:00 AM"   AND  ( 'Status*'  = "Assigned" OR 'Status*'  = "In Progress" OR 'Status*'  = "Pending" ))


#########
CRQ steps :

What:
Database Reorg / Changing DB Parameter to fix Incident / Recycle DB / Export-Import……………….etc

Where:
HLQ : PIM
Server: lcllxp73
Database: P138
Data Centre: KDC

Why:
Performing this change in order to improve performance / Business requirement / Fix Incident-PRB-PKE refrence……………..etc

When:
CRQ start and End Schedule

How:
Implementation Plan attached.

Impact:
Database re-boot required : No
Server re-boor required : No

Urgency:
Normal / Critical-High Issue needs to be fixed / Justtification mail attached………………etc 
=======

--**************************************************************

--   session.sql  © 2002 by Donald K. Burleson

--**************************************************************

rem session.sql - displays all connected sessions
spool remove.sql
set echo off;
set termout on;
set linesize 80;
set pagesize 60;
set newpage 0;
select    rpad(c.name||':',11)||rpad(' current logons='||(to_number(b.sessions_current)),20)||'cumulative logons='||rpad(substr(a.value,1,10),10)||'highwater mark='||b.sessions_highwater Information
from    v$sysstat a,   v$license b,   v$database c
where   a.name = 'logons cumulative';
ttitle "dbname Database|UNIX/Oracle Sessions";
set heading off;
select 'Sessions on database '||substr(name,1,8) from v$database;
set heading on;
select    substr(a.spid,1,9) pid,   substr(b.sid,1,5) sid,   substr(b.serial#,1,5) ser#,   substr(b.machine,1,6) box,   substr(b.username,1,10) username,   substr(b.osuser,1,8) os_user,   substr(b.program,1,30) program
from   v$session b,   v$process a
where   b.paddr = a.addr
and    type='USER'order by   spid;
ttitle off;
set heading off;
select 'To kill, enter SQLPLUS>  ALTER SYSTEM KILL SESSION',''''||'SID, SER#'||''''||';' from dual;
spool off;


######################DB CREATION SCRIPT##############################

CREATE DATABASE FRGENP11TEMP
    MAXLOGFILES 16
    MAXLOGMEMBERS 3
    MAXDATAFILES 100
    MAXINSTANCES 8
    MAXLOGHISTORY 292
LOGFILE
  GROUP 1 '/oralog1/FRGENP11TEMP/redo_g03_m01.rdo'  SIZE 50M,
  GROUP 2 '/oralog1/FRGENP11TEMP/redo_g03_m02.rdo'  SIZE 50M,
  GROUP 3 '/oralog1/FRGENP11TEMP/redo_g03_m03.rdo'  SIZE 50M
UNDO TABLESPACE UNDOTBS1
DATAFILE 'E:\ORACLE\PRODUCT\10.2.0\ORADATA\ORCM\UNDOTBS1.DBF' SIZE 40M
SYSAUX DATAFILE 'E:\ORACLE\PRODUCT\10.2.0\ORADATA\ORCM\SYSAUX01.DBF' SIZE 40M
DATAFILE
  'E:\ORACLE\PRODUCT\10.2.0\ORADATA\ORCM\SYSTEM01.DBF' SIZE 40M,
  'E:\ORACLE\PRODUCT\10.2.0\ORADATA\ORCM\USERS01.DBF' SIZE 40M,
  'E:\ORACLE\PRODUCT\10.2.0\ORADATA\ORCM\EXAMPLE01.DBF' SIZE 40M
CHARACTER SET AL32UTF8
;

CREATE DATABASE DATABASE_NAME
    MAXLOGFILES 16
    MAXLOGMEMBERS 3
    MAXDATAFILES 100
    MAXINSTANCES 8
    MAXLOGHISTORY 292
LOGFILE
  GROUP 1 'E:\ORACLE\PRODUCT\10.2.0\ORADATA\ORCM\REDO01.LOG'  SIZE 50M,
  GROUP 2 'E:\ORACLE\PRODUCT\10.2.0\ORADATA\ORCM\REDO02.LOG'  SIZE 50M,
  GROUP 3 'E:\ORACLE\PRODUCT\10.2.0\ORADATA\ORCM\REDO03.LOG'  SIZE 50M
UNDO TABLESPACE UNDOTBS1
DATAFILE 'E:\ORACLE\PRODUCT\10.2.0\ORADATA\ORCM\UNDOTBS1.DBF' SIZE 40M
SYSAUX DATAFILE 'E:\ORACLE\PRODUCT\10.2.0\ORADATA\ORCM\SYSAUX01.DBF' SIZE 40M
DATAFILE
  'E:\ORACLE\PRODUCT\10.2.0\ORADATA\ORCM\SYSTEM01.DBF' SIZE 40M,
  'E:\ORACLE\PRODUCT\10.2.0\ORADATA\ORCM\USERS01.DBF' SIZE 40M,
  'E:\ORACLE\PRODUCT\10.2.0\ORADATA\ORCM\EXAMPLE01.DBF' SIZE 40M
CHARACTER SET AL32UTF8
;

For Silent Installation:
----------------------

dbca -silent \
-createDatabase \
-templateName /u01/app/oracle/product/11.2.0.3/GARDSOA/assistants/dbca/templates/General_Purpose.dbc \
-gdbName avitest \
-sid avitest \
-sysPassword syspassword \
-systemPassword systempassword \
-memoryPercentage 5 \
-redoLogFileSize 100   \
-recoveryAreaDestination RECODG \
-storageType ASM             \
-diskGroupName DATADG \
-listeners LISTENER   \
-nodelist ospexacoedb01,ospexacoedb02



dbca -silent -createDatabase \
 -templateName General_Purpose.dbc \
 -gdbname AVIPOC -sid AVIPOC -responseFile NO_VALUE \
 -characterSet AL32UTF8 \
 -sysPassword Ch@ngeme123# \
 -systemPassword Ch@ngeme123# \
 -createAsContainerDatabase true \
 -numberOfPDBs 1 \
 -pdbName AVIPOCPDB \
 -pdbAdminPassword Ch@ngeme123# \
 -databaseType MULTIPURPOSE \
 -automaticMemoryManagement false \
 -asmSysPassword Ch@ngeme123# \
 -diskGroupName DATADG \
 -recoveryAreaDestination RECODG \
 -totalMemory 3000 \
 -storageType ASM \
 -redoLogFileSize 50 \
 -emConfiguration NONE \
 -ignorePreReqs



#########################UPGRADE########################################

Upgrading to Oracle Database 11g
Upgrade path
You can directly upgrade to Oracle 11g, if your current database is 9.2.04 or newer. In other words, it supports direct upgrade to versions 9.2.0.4, 10.1 and 10.2. Otherwise, you should follow one of the upgrade paths:
7.3.3 -> 7.3.4 -> 9.2.0.8 -> 11.1
8.0.5 -> 8.0.6 -> 9.2.0.8 -> 11.1
8.1.7 -> 8.1.7.4 -> 9.2.0.8 -> 11.1
9.0.1.3-> 9.0.1.4 -> 9.2.0.8 -> 11.1
9.2.0.3 (or lower) -> 9.2.0.8 -> 11.1
Oracle 11g client can access Oracle databases of versions 8i, 9i and 10g.


CREATE TABLESPACE TAQA_IRAQ_TEST_DATA
DATAFILE 'O:\APP\ORADATA\DCTMT\TAQA_IRAQ_TEST_DATA01.DBF' 
SIZE 1000M
AUTOEXTEND ON NEXT 400M MAXSIZE 3000M
default storage ( initial 65536 minextents 1 maxextents unlimited);

CREATE TABLESPACE TAQA_IRAQ_TEST_INDEX
DATAFILE 'O:\APP\ORADATA\DCTMT\TAQA_IRAQ_TEST_INDEX01.DBF' 
SIZE 800M
AUTOEXTEND ON NEXT 300M MAXSIZE 2500M
default storage ( initial 65536 minextents 1 maxextents unlimited);


##############Installing 11g on Windows#####################################

1. Double-click on setup.exe from the /db/Disk1 directory.

2. Select a product to install from the below three:
- Oracle Database 11g
- Oracle Client
- Oracle Clusterware
Click Next



3. Select Installation Method : Select Basic Installation
Oracle Base Location : D:\app\oracle
Oracle Home Location : D:\app\oracle\product\11.2.0\dbhome_1
Installation Type : Enterprise Edition (2.9 GB)

Can create a starter Database (additional 1482MB)
Global Database Name : orcl
Database Password : oracle
Confirm Password : oracle
Click Next

4. Oracle Configuration Manager Registration :
OCM allows us to associate our configuration information with our metalink a/c.We can shoose to enable it on this window.
Click Next

5. Summary :
Review the summary window to verify what is to be installed.
Click Install.

6. The PROGRESS window appears.

7. Configuration Assistants :

Tool Name : Oracle Net Configuration Assistant
Oracle Database Configuration Assistant.
The configuration Assistants window appears.

8. Our Database is now being created.

It will show the below :
- Copying database files.
- Creating and starting Oracle instance.
- Completing Database Creation.

9. Database Configuration Assistant :
Database creation complete. For details check the logfiles at :
Click OK

10. Click EXIT. Click Yes to confirm exit.
Testing Your Installation :

1. Open a browser and enter the following URL :
https://<hostname>:1158/em
Where <hostname> should be changed to our machine name, IP Address, or localhost.

2. Enter SYSTEM as the User Name and oracle as the password, and then click Login.

3. The Database Control Home Page appears. Your installation was successful.


C:\Documents and Settings\-adm-agara0>set oracle_sid=coabisp

C:\Documents and Settings\-adm-agara0>set oracle_home=D:\app\oracle\product\11.2.0\dbhome_1

C:\Documents and Settings\-adm-agara0>set PATH=%ORACLE_HOME%\bin;%PATH%



\Documents and Settings\-adm-agara0>orapwd file=D:\app\oracle\product\10.2.0\db_1\database\PWDcoabisp.ora password=oratist100sys100

\Documents and Settings\-adm-agara0>oradim -new -sid COABISP -startmode auto -pfile D:\app\oracle\product\10.2.0\db_1\database\initCOABISP.ora
stance created.



######################Oracle Client###################################

-----Clone Oracle Client-------------------------------------------

mkdir -p /opt/oracle/product/11.2.0 

scp -r client11g.tar oracle@xsnl10x202c:/opt/oracle/product/11.2.0 

tar -xvf client11g.tar 

cd /opt/oracle/product/11.2.0/client11g

[oracle@xspl11a802k client11g]$ cd clone
[oracle@xspl11a802k clone]$ cd bin
[oracle@xspl11a802k bin]$ pwd
/opt/oracle/product/11.2.0/client11g/clone/bin
[oracle@xspl11a802k bin]$ perl clone.pl ORACLE_HOME=/opt/oracle/product/11.2.0/client11g ORACLE_BASE=/opt/oracle

export TMP=/opt/oracle 
export ORACLE_HOME=/opt/oracle/product/11.2.0/client11g 
export ORACLE_BASE=/opt/oracle 
export PATH=/opt/oracle/product/11.2.0/client11g/bin:$PATH 

cd /opt/oracle/product/11.2.0/client11g/lib/stubs

Client source : xsnl10x029x [for linux] , xsnh10x004c[unix] for 11g


--------------------How to De-install : Go to client home then deinstall then run deinstall.--------------------------------------

How to re-link libraries ?
--------------------------
cd $ORACLE_HOME/bin , then relink all 

How to clone client software ?
--------------------------------

Run $ORACLE_HOME/clone/clone.pl


oracle@xsnh10c499b:# scp p10404530_112030_Linux-x86-64_4of7.zip


####################Cloning Oracle Agent11g##############################################

1. Go to source - xsnh10c499b
    then, cd /opt/oracle/product
    then, scp -r agent11g oracle@<>:/opt/oracle/product/

2. Now at Target <> Edit /opt/oracle/oraInventory/ContentsXML/inventory.xml and remove the agent11g home.

3.Then cd /opt/oracle/product/agent11g/oui/bin and run the below:

./runInstaller -clone -forceClone ORACLE_HOME=/opt/oracle/product/agent11g ORACLE_HOME_NAME=Agent11g_Home -noconfig -silent

4. Then Run the root.sh from root located at /opt/oracle/product/agent11g

5. Then cd /opt/oracle/product/agent11g/bin

./agentca -f

6. Check the agent status ..

7. If Not running, do the following:

./emctl unsecure agent
./emctl secure agent


#######################Installing Grid Control Agent########################################


Following are the steps required to install agent on standalone hosts
1- Perform below changes on the “additional_agent.rsp” file located on “/oracle_bin/agent/hpi/response”.

SECURITY_UPDATES_VIA_MYORACLESUPPORT=FALSE
DECLINE_SECURITY_UPDATES=TRUE
ORACLE_AGENT_HOME_LOCATION=/opt/oracle/product/
OMS_HOST=<Hostname>.pharma.aventis.com
OMS_PORT=4900
AGENT_REGISTRATION_PASSWORD=XXXX
 
2- After changing the script start the silent installation on the machine where we want to install the agent.

3- /opt/oracle/agent/hpi/agent/runInstaller -silent -responseFile /opt/oracle/agent/hpi/response/additional_agent.rsp

4- At the end of the installation run the following script as root user:
sudo /opt/oracle/product/agent11g/root.sh 




##################Issue the following commands to failover over the standby to a primary mode#################

Server : STANDBY Server 

1.            ALTER DATABASE RECOVER MANAGED STANDBY DATABASE FINISH FORCE;

2.            ALTER DATABASE COMMIT TO SWITCHOVER TO PRIMARY;

3.            If database has not been opened then issue  ALTER DATABASE OPEN;
If it has been opened in read-only mode then do a SHUTDOWN IMMEDIATE; and then STARTUP;

4.            To confirm database role issue the following select statement

Select database_role from v$database;





#########################Take RMAN Backup & Restore###########################################################

run
{
allocate channel c1 type disk format '/oradata1/backup/backup_%d_%I_%T_%s_%p';
allocate channel c2 type disk format '/oradata1/backup/backup_%d_%I_%T_%s_%p';
backup as compressed backupset database ;
backup current controlfile format '/oradata1/backup/controlfile_%d_%I_%T_%s_%p.bkp';
backup spfile format '/oradata1/backup/spfile_%d_%I_%T_%s_%p.bkp';
release channel c1;
release channel c2;
sql 'alter system archive log current';
allocate channel c1 type disk format '/oradata1/backup/archbkp_%d_%I_%T_%s_%p';
allocate channel c2 type disk format '/oradata1/backup/archbkp_%d_%I_%T_%s_%p';
backup archivelog all format '/oradata1/backup/archbkp_%d_%I_%T_%s_%p';
release channel c1;
release channel c2;
}

Take level 0 backup :
-------------------

RUN {
ALLOCATE CHANNEL ch0 TYPE DISK FORMAT '/oraexp/llp3dev/%U';
set controlfile autobackup format for device type disk to '/oraexp/llp3dev/cf_%F';
backup incremental level 0 as compressed backupset database plus archivelog;
RELEASE CHANNEL ch0;

To Restore the above backup :
-----------------------------

Create the same dir. structures,catalog the backup pieces and then restore the control file, then unmount the database and run the below :

run {
ALLOCATE CHANNEL ch0 TYPE DISK;
restore database;

Then

recover database;

------------Restore Commands---------------------------------------

run
{
ALLOCATE CHANNEL T1 DEVICE TYPE DISK FORMAT '/oraexp/F3_TO_KEEP/20140124/bck_full_%U.dmp';
restore controlfile from '/oraexp/F3_TO_KEEP/20140124/bck_full_bgous7j2_1_1.dmp';
}


run
{
ALLOCATE CHANNEL T1 DEVICE TYPE DISK FORMAT '/oraexp/F3_TO_KEEP/20140124/bck_full_%U.dmp';
ALLOCATE CHANNEL T2 DEVICE TYPE DISK FORMAT '/oraexp/F3_TO_KEEP/20140124/bck_full_%U.dmp';
ALLOCATE CHANNEL T3 DEVICE TYPE DISK FORMAT '/oraexp/F3_TO_KEEP/20140124/bck_full_%U.dmp';
ALLOCATE CHANNEL T4 DEVICE TYPE DISK FORMAT '/oraexp/F3_TO_KEEP/20140124/bck_full_%U.dmp';
restore database preview;
}

run
{
ALLOCATE CHANNEL T1 DEVICE TYPE DISK FORMAT '/oraexp/F3_TO_KEEP/20140124/bck_full_%U.dmp';
ALLOCATE CHANNEL T2 DEVICE TYPE DISK FORMAT '/oraexp/F3_TO_KEEP/20140124/bck_full_%U.dmp';
ALLOCATE CHANNEL T3 DEVICE TYPE DISK FORMAT '/oraexp/F3_TO_KEEP/20140124/bck_full_%U.dmp';
ALLOCATE CHANNEL T4 DEVICE TYPE DISK FORMAT '/oraexp/F3_TO_KEEP/20140124/bck_full_%U.dmp';
set until time "TO_DATE('24/01/2014 23:59:00','DD/MM/YYYY HH24:MI:SS')";
restore database;
recover database;
}

-----------------------------------Duplicate Commands------------------------------------------------------------------------------

run {
allocate channel t1 type 'SBT_TAPE' PARMS='BLKSIZE=1048576,ENV=(NB_ORA_POLICY=P-E21-MI-ORAL-FULL,NB_ORA_CLIENT=xspl10p155x)';
allocate channel t2 type 'SBT_TAPE' PARMS='BLKSIZE=1048576,ENV=(NB_ORA_POLICY=P-E21-MI-ORAL-ARCH,NB_ORA_CLIENT=xspl10p155x)';
allocate channel t3 type 'SBT_TAPE' PARMS='BLKSIZE=1048576,ENV=(NB_ORA_POLICY=P-E21-MI-ORAL-INCR,NB_ORA_CLIENT=xspl10p155x)'; 
allocate auxiliary channel t4 type 'SBT_TAPE' PARMS='BLKSIZE=1048576,ENV=(NB_ORA_POLICY=P-E21-MI-ORAL-FULL,NB_ORA_CLIENT=xspl10p155x)';
allocate auxiliary channel t5 type 'SBT_TAPE' PARMS='BLKSIZE=1048576,ENV=(NB_ORA_POLICY=P-E21-MI-ORAL-ARCH,NB_ORA_CLIENT=xspl10p155x)';
allocate auxiliary channel t6 type 'SBT_TAPE' PARMS='BLKSIZE=1048576,ENV=(NB_ORA_POLICY=P-E21-MI-ORAL-INCR,NB_ORA_CLIENT=xspl10p155x)';
set until time "to_date('2014-05-22:00:00:00','YYYY-MM-DD:hh24:mi:ss')";
duplicate target database to 'O1S15657';
db_file_name_convert=('/oradata1/O1D15657','/oradata1/O1S15657','/oradata2/O1D15657','/oradata2/O1S15657','/oratemp1/O1D15657','/oratemp1/O1S15657')
log_file_name_convert=('/oralog1/O1D15657','/oralog1/O1S15657','/oralog2/O1D15657','/oralog2/O1S15657')
} 

--------------------------------------------------------------------------------

nohup rman target / cmdfile=/path_to_backup/mybackup.cfg log=/path_to_backup/mybackup.log  &

rman target sys/Mar042011@O1P10447 catalog rmanp_11g/rmand@O1P00002DG1 auxiliary sys/Mar042011@O2P10447

run
{
allocate channel t1 type 'SBT_TAPE' PARMS='ENV=(NB_ORA_CLIENT=xsph10f798wc.pharma.aventis.com,NB_ORA_POLICY=P-E21-BE-ORA-FULL)';
allocate channel t2 type 'SBT_TAPE' PARMS='ENV=(NB_ORA_CLIENT=xsph10f798wc.pharma.aventis.com,NB_ORA_POLICY=P-E21-BE-ORA-FULL)';
allocate channel t3 type 'SBT_TAPE' PARMS='ENV=(NB_ORA_CLIENT=xsph10f798wc.pharma.aventis.com,NB_ORA_POLICY=P-E21-BE-ORA-INCR)';
allocate channel t4 type 'SBT_TAPE' PARMS='ENV=(NB_ORA_CLIENT=xsph10f798wc.pharma.aventis.com,NB_ORA_POLICY=P-E21-BE-ORA-INCR)';
allocate channel t5 type 'SBT_TAPE' PARMS='BLKSIZE=1048576,ENV=(NB_ORA_CLIENT=xsph10f798wc.pharma.aventis.com,NB_ORA_POLICY=P-E21-BE-ORA-ARCH)';
allocate auxiliary channel a1 type 'SBT_TAPE' PARMS='ENV=(NB_ORA_CLIENT=xsph10f798wc.pharma.aventis.com,NB_ORA_POLICY=P-E21-BE-ORA-INCR)';
allocate auxiliary channel a2 type 'SBT_TAPE' PARMS='ENV=(NB_ORA_CLIENT=xsph10f798wc.pharma.aventis.com,NB_ORA_POLICY=P-E21-BE-ORA-INCR)';
allocate auxiliary channel a3 type 'SBT_TAPE' PARMS='ENV=(NB_ORA_CLIENT=xsph10f798wc.pharma.aventis.com,NB_ORA_POLICY=P-E21-BE-ORA-ARCH)'; 
allocate auxiliary channel a4 type 'SBT_TAPE' PARMS='ENV=(NB_ORA_CLIENT=xsph10f798wc.pharma.aventis.com,NB_ORA_POLICY=P-E21-BE-ORA-ARCH)';
allocate auxiliary channel a5 type 'SBT_TAPE' PARMS='ENV=(NB_ORA_CLIENT=xsph10f798wc.pharma.aventis.com,NB_ORA_POLICY=P-E21-BE-ORA-FULL)'; 
allocate auxiliary channel a6 type 'SBT_TAPE' PARMS='ENV=(NB_ORA_CLIENT=xsph10f798wc.pharma.aventis.com,NB_ORA_POLICY=P-E21-BE-ORA-FULL)';
set until time "to_date('2014-03-18:05:00:00','YYYY-MM-DD:hh24:mi:ss')";
duplicate target database to O2P10447;
}


---------------------------------------------------------------------------------

RUN
{
  ALLOCATE AUXILIARY CHANNEL AuxCh1 TYPE  'SBT_TAPE'  PARMS 'BLKSIZE=1048576,ENV=(NB_ORA_CLIENT=xsph10a937c,NB_ORA_POLICY=P-E21-BE-ORA-FULL)';
  ALLOCATE AUXILIARY CHANNEL AuxCh2 TYPE  'SBT_TAPE'  PARMS 'BLKSIZE=1048576,ENV=(NB_ORA_CLIENT=xsph10a937c,NB_ORA_POLICY=P-E21-BE-ORA-FULL)';
  ALLOCATE AUXILIARY CHANNEL AuxCh3 TYPE  'SBT_TAPE'  PARMS 'BLKSIZE=1048576,ENV=(NB_ORA_CLIENT=xsph10a937c,NB_ORA_POLICY=P-E21-BE-ORA-FULL)';
  ALLOCATE AUXILIARY CHANNEL AuxCh4 TYPE  'SBT_TAPE'  PARMS 'BLKSIZE=1048576,ENV=(NB_ORA_CLIENT=xsph10a937c,NB_ORA_POLICY=P-E21-BE-ORA-FULL)';
  ALLOCATE AUXILIARY CHANNEL AuxCh5 TYPE  'SBT_TAPE'  PARMS 'BLKSIZE=1048576,ENV=(NB_ORA_CLIENT=xsph10a937c,NB_ORA_POLICY=P-E21-BE-ORA-ARCH)';
  ALLOCATE AUXILIARY CHANNEL AuxCh6 TYPE  'SBT_TAPE'  PARMS 'BLKSIZE=1048576,ENV=(NB_ORA_CLIENT=xsph10a937c,NB_ORA_POLICY=P-E21-BE-ORA-ARCH)';
  ALLOCATE AUXILIARY CHANNEL AuxCh7 TYPE  'SBT_TAPE'  PARMS 'BLKSIZE=1048576,ENV=(NB_ORA_CLIENT=xsph10a937c,NB_ORA_POLICY=P-E21-BE-ORA-INCR)';
  ALLOCATE AUXILIARY CHANNEL AuxCh8 TYPE  'SBT_TAPE'  PARMS 'BLKSIZE=1048576,ENV=(NB_ORA_CLIENT=xsph10a937c,NB_ORA_POLICY=P-E21-BE-ORA-INCR)';
  SET UNTIL TIME 'sysdate-1';
  DUPLICATE TARGET DATABASE TO O1D10245;

}

----------------------------------------------------------------------------------


connect target sys/Mar042011@O2P10896;
connect catalog  rmanp_10g/rmand@O1P00002;
connect AUXILIARY sys/Mar042011@O6S10896;


run
{
set newname for datafile '/oradata1/O2P10896/system01.dbf' to '/oradata1/O6S10896/system01.dbf';
set newname for datafile '/oradata1/O2P10896/undotbs01.dbf' to '/oradata1/O6S10896/undotbs01.dbf';
set newname for datafile '/oradata1/O2P10896/sysaux01.dbf' to '/oradata1/O6S10896/sysaux01.dbf';
set newname for datafile '/oradata1/O2P10896/users01.dbf' to '/oradata1/O6S10896/users01.dbf';
set newname for datafile '/oradata1/O2P10896/TS_patconfig_DAT01.dbf' to '/oradata1/O6S10896/TS_patconfig_DAT01.dbf';
set newname for datafile '/oradata1/O2P10896/tools01.dbf' to '/oradata3/O6S10896/tools01.dbf';
set newname for datafile '/oradata1/O2P10896/TS_OGG_DAT01.dbf' to '/oradata3/O6S10896/TS_OGG_DAT01.dbf';
set newname for datafile '/oradata1/O2P10896/PERFSTAT_DATA01.dbf' to '/oradata1/O6S10896/PERFSTAT_DATA01.dbf';
set newname for datafile '/oradata1/O2P10896/PHENIX_LOBS01.dbf' to '/oradata2/O6S10896/PHENIX_LOBS01.dbf';
set newname for datafile '/oradata1/O2P10896/PHENIX_LOBS02.dbf' to '/oradata2/O6S10896/PHENIX_LOBS02.dbf';
set newname for datafile '/oradata1/O2P10896/PHENIX_LOBS03.dbf' to '/oradata2/O6S10896/PHENIX_LOBS03.dbf';
set newname for datafile '/oradata1/O2P10896/PHENIX_LOBS04.dbf' to '/oradata2/O6S10896/PHENIX_LOBS04.dbf';
set newname for datafile '/oradata1/O2P10896/PHENIX_LOBS05.dbf' to '/oradata2/O6S10896/PHENIX_LOBS05.dbf';
set newname for datafile '/oradata1/O2P10896/PHENIX_LOBS06.dbf' to '/oradata2/O6S10896/PHENIX_LOBS06.dbf';
set newname for datafile '/oradata1/O2P10896/PHENIX_LOBS07.dbf' to '/oradata2/O6S10896/PHENIX_LOBS07.dbf';
set newname for datafile '/oradata1/O2P10896/PHENIX_LOBS08.dbf' to '/oradata3/O6S10896/PHENIX_LOBS08.dbf';
set newname for datafile '/oradata1/O2P10896/PHENIX_LOBS09.dbf' to '/oradata3/O6S10896/PHENIX_LOBS09.dbf';
set newname for datafile '/oradata3/O2P10896/PHENIX_LOBS10.dbf' to '/oradata1/O6S10896/PHENIX_LOBS10.dbf';
set newname for datafile '/oradata1/O2P10896/PHENIX_LOBS11.dbf' to '/oradata3/O6S10896/PHENIX_LOBS11.dbf';
set newname for datafile '/oradata1/O2P10896/PHENIX_LOBS12.dbf' to '/oradata3/O6S10896/PHENIX_LOBS12.dbf';
set newname for datafile '/oradata1/O2P10896/PHENIX_LOBS13.dbf' to '/oradata3/O6S10896/PHENIX_LOBS13.dbf';
set newname for datafile '/oradata2/O2P10896/PHENIX_LOBS14.dbf' to '/oradata3/O6S10896/PHENIX_LOBS14.dbf';
set newname for datafile '/oradata2/O2P10896/PHENIX_LOBS15.dbf' to '/oradata3/O6S10896/PHENIX_LOBS15.dbf';
set newname for datafile '/oradata1/O2P10896/PHENIX_DATA01.dbf' to '/oradata3/O6S10896/PHENIX_DATA01.dbf';
set newname for datafile '/oradata1/O2P10896/PHENIX_DATA02.dbf' to '/oradata3/O6S10896/PHENIX_DATA02.dbf';
set newname for datafile '/oradata1/O2P10896/PHENIX_INDX01.dbf' to '/oradata1/O6S10896/PHENIX_INDX01.dbf';
set newname for tempfile '/oratemp1/O2P10896/temp02.dbf' to '/oratemp1/O6S10896/temp01.dbf';
allocate channel t1 type 'SBT_TAPE' PARMS='ENV=(NB_ORA_CLIENT=xsph10f460c,NB_ORA_POLICY=P-E11-BE-ORA-FULL)';
allocate channel t2 type 'SBT_TAPE' PARMS='ENV=(NB_ORA_CLIENT=xsph10f460c,NB_ORA_POLICY=P-E11-BE-ORA-INCR)';
allocate channel t3 type 'SBT_TAPE' PARMS='ENV=(NB_ORA_CLIENT=xsph10f460c,NB_ORA_POLICY=P-E11-BE-ORA-ARCH)';
allocate auxiliary channel aux1 type 'SBT_TAPE' PARMS='ENV=(NB_ORA_CLIENT=xsph10f460c,NB_ORA_POLICY=P-E11-BE-ORA-FULL)';
allocate auxiliary channel aux2 type 'SBT_TAPE' PARMS='ENV=(NB_ORA_CLIENT=xsph10f460c,NB_ORA_POLICY=P-E11-BE-ORA-INCR)';
allocate auxiliary channel aux3 type 'SBT_TAPE' PARMS='ENV=(NB_ORA_CLIENT=xsph10f460c,NB_ORA_POLICY=P-E11-BE-ORA-ARCH)';
set until time "to_date('2014-10-22:21:15:21', 'yyyy-mm-dd:hh24:mi:ss')";
duplicate target database to 'O6S10896';
}



rman auxiliary /

run
{
set newname for datafile '/u01/app/oracle/oradata/avitest/read_only.dbf' to '/u01/app/oracle/oradata/avidup/read_only.dbf';
set newname for datafile '/u01/app/oracle/oradata/avitest/example01.dbf' to '/u01/app/oracle/oradata/avidup/example01.dbf';
set newname for datafile '/u01/app/oracle/oradata/avitest/users01.dbf' to '/u01/app/oracle/oradata/avidup/users01.dbf';
set newname for datafile '/u01/app/oracle/oradata/avitest/undotbs01.dbf' to '/u01/app/oracle/oradata/avidup/undotbs01.dbf';
set newname for datafile '/u01/app/oracle/oradata/avitest/sysaux01.dbf' to '/u01/app/oracle/oradata/avidup/sysaux01.dbf';
set newname for datafile '/u01/app/oracle/oradata/avitest/system01.dbf' to '/u01/app/oracle/oradata/avidup/system01.dbf';
set newname for tempfile '/u01/app/oracle/oradata/avitest/temp01.dbf' to '/u01/app/oracle/oradata/avidup/temp01.dbf';
allocate auxiliary channel t1 type disk;
allocate auxiliary channel t2 type disk;
allocate auxiliary channel t3 type disk;
duplicate database to 'avidup' backup location '/home/oracle/rman';
RELEASE CHANNEL t1;
RELEASE CHANNEL t2;
RELEASE CHANNEL t3;
}



log_file_name_convert=('O2P10896','O6S10896')



(SID_DESC =
      (GLOBAL_DBNAME = O2P10896.pharma.aventis.com)
      (ORACLE_HOME = /opt/oracle/product/10.2.0.5)
      (SID_NAME = O2P10896)
    )
*.LOG_FILE_NAME_CONVERT=('O2P10896','O6S10896')

connect target sys/Mar042011@O2P10896
catalog  rmanp_10g/rmand@O1P00002 
auxiliary /


---------------------------To restore a database from the last backup of a different  running database-------------------------

run
{
set newname for datafile '/oradata1/O1Z11798/system01.dbf' to '/oradata1/O4Z11798/system01.dbf';
set newname for datafile '/oradata1/O1Z11798/sysaux01.dbf' to '/oradata1/O4Z11798/sysaux01.dbf';
set newname for datafile '/oradata1/O1Z11798/undotbs01.dbf' to '/oradata1/O4Z11798/undotbs01.dbf';
set newname for datafile '/oradata1/O1Z11798/users01.dbf' to '/oradata1/O4Z11798/users01.dbf';
set newname for datafile '/oradata1/O1Z11798/GEF_USER_01.dbf' to '/oradata1/O4Z11798/GEF_USER_01.dbf';
set newname for datafile '/oradata1/O1Z11798/GEF_DATA1_01.dbf' to '/oradata1/O4Z11798/GEF_DATA1_01.dbf';
set newname for datafile '/oradata1/O1Z11798/GEF_DATA2_01.dbf' to '/oradata1/O4Z11798/GEF_DATA2_01.dbf';
set newname for datafile '/oradata1/O1Z11798/GEF_DATA2_02.dbf' to '/oradata1/O4Z11798/GEF_DATA2_02.dbf';
set newname for datafile '/oradata1/O1Z11798/GEFF_DATA3_01.dbf' to '/oradata1/O4Z11798/GEFF_DATA3_01.dbf';
set newname for datafile '/oradata1/O1Z11798/GEF_INDX_01.dbf' to '/oradata1/O4Z11798/GEF_INDX_01.dbf';
set newname for tempfile '/oratemp1/O1Z11798/temp01.dbf' to '/oratemp1/O4Z11798/temp01.dbf';
allocate channel t1 type 'SBT_TAPE' PARMS='ENV=(NB_ORA_CLIENT=xsnh10f956k.pharma.aventis.com,NB_ORA_POLICY=N-E21-MI-ORA-FULL)';
allocate channel t2 type 'SBT_TAPE' PARMS='ENV=(NB_ORA_CLIENT=xsnh10f956k.pharma.aventis.com,NB_ORA_POLICY=N-E21-MI-ORA-FULL)';
allocate channel t3 type 'SBT_TAPE' PARMS='ENV=(NB_ORA_CLIENT=xsnh10f956k.pharma.aventis.com,NB_ORA_POLICY=N-E21-MI-ORA-INCR)';
allocate channel t4 type 'SBT_TAPE' PARMS='ENV=(NB_ORA_CLIENT=xsnh10f956k.pharma.aventis.com,NB_ORA_POLICY=N-E21-MI-ORA-INCR)';
allocate channel t5 type 'SBT_TAPE' PARMS='BLKSIZE=1048576,ENV=(NB_ORA_CLIENT=xsnh10f956k.pharma.aventis.com,NB_ORA_POLICY=N-E21-MI-ORA-ARCH)';
allocate auxiliary channel a1 type 'SBT_TAPE' PARMS='ENV=(NB_ORA_CLIENT=xsnh10f956k.pharma.aventis.com,NB_ORA_POLICY=N-E21-MI-ORA-INCR)';
allocate auxiliary channel a2 type 'SBT_TAPE' PARMS='ENV=(NB_ORA_CLIENT=xsnh10f956k.pharma.aventis.com,NB_ORA_POLICY=N-E21-MI-ORA-INCR)';
allocate auxiliary channel a3 type 'SBT_TAPE' PARMS='ENV=(NB_ORA_CLIENT=xsnh10f956k.pharma.aventis.com,NB_ORA_POLICY=N-E21-MI-ORA-ARCH)'; 
allocate auxiliary channel a4 type 'SBT_TAPE' PARMS='ENV=(NB_ORA_CLIENT=xsnh10f956k.pharma.aventis.com,NB_ORA_POLICY=N-E21-MI-ORA-ARCH)';
allocate auxiliary channel a5 type 'SBT_TAPE' PARMS='ENV=(NB_ORA_CLIENT=xsnh10f956k.pharma.aventis.com,NB_ORA_POLICY=N-E21-MI-ORA-FULL)'; 
allocate auxiliary channel a6 type 'SBT_TAPE' PARMS='ENV=(NB_ORA_CLIENT=xsnh10f956k.pharma.aventis.com,NB_ORA_POLICY=N-E21-MI-ORA-FULL)';
set until sequence 1658;
duplicate target database to O4Z11798
LOGFILE
GROUP 1 ('/oralog1/O4Z11798/redo_g01_m01.rdo','/oralog2/O4Z11798/redo_g01_m02.rdo') SIZE 1024M REUSE,
GROUP 2 ('/oralog1/O4Z11798/redo_g02_m01.rdo','/oralog2/O4Z11798/redo_g02_m02.rdo') SIZE 1024M REUSE,
GROUP 3 ('/oralog1/O4Z11798/redo_g03_m01.rdo','/oralog2/O4Z11798/redo_g03_m02.rdo') SIZE 1024M REUSE; 
}

####################Static Listener entry######################

SID_LIST_LISTENER10 =
(SID_LIST =
(SID_DESC =
(GLOBAL_DBNAME = O4Z11798)
(ORACLE_HOME = /opt/oracle/product/10.2.0.5)
(SID_NAME = O4Z11798)
)
)

################################Steps to Clone 9i Binaries on HP-UX##################################

1.	Copy the binaries from an existing server (like xsnh10c499b, xsnh10w533s) to the target server. (Estimate time 30 minutes)

(At Source Server)
# cd /opt/oracle/product
# scp –r 9.2.0.8 oracle@<target server>:/opt/oracle/product/


2.	Copy the following directory from source server to the target server. (Estimate time 20 minutes, this can be done in parallel with step 1)

(At Source Server)
# cd /opt/oracle/
# scp –r jre oracle@<target server>:/opt/oracle/


3.	Now follow the following commands: 

(At Target Server)
# cd /opt/oracle/product/9.2.0.8
# rm –rf JRE
# ln –s /opt/oracle/jre/1.3.1 JRE
#
# ls -ldr JRE
lrwxrwxr-x   1 oracle     dba             21 Jan 18  2012 JRE -> /opt/oracle/jre/1.3.1
#
#

# cd /opt/oracle/jre/1.3.1/lib/IA64
# rm –rf libmawt.so hotspot
# ln –s /opt/oracle/jre/1.3.1/lib/IA64/motif21/libmawt.so libmawt.so
# ln –s /opt/oracle/jre/1.3.1/lib/IA64/server hotspot
# ls -lrt|tail -2
lrwxrwxr-x   1 oracle     dba             37 Jan 18  2012 hotspot -> /opt/oracle/jre/1.3.1/lib/IA64/server
lrwxrwxr-x   1 oracle     dba             49 Jan 18  2012 libmawt.so -> /opt/oracle/jre/1.3.1/lib/IA64/motif21/libmawt.so
#


4.	Check the OPATCH LSINVENTORY and this is expected to fail.

Manually edit inventory.xml file located at central inventory to attach the 9i home.

oracle@xsnh10w533s:# pwd
/opt/oracle/oraInventory/ContentsXML
oracle@xsnh10w533s:#
oracle@xsnh10w533s:# ls -lrt
total 48
-rwxr-xr-x   1 oracle     dba            311 Apr 16 12:10 comps.xml
-rwxr-xr-x   1 oracle     dba            274 Apr 16 12:10 libs.xml
-rwxr-xr-x   1 oracle     dba            768 Apr 16 12:19 inventory.xml
oracle@xsnh10w533s:# cat inventory.xml
<?xml version="1.0" standalone="yes" ?>
<!-- Copyright (c) 2002 Oracle Corporation. All rights Reserved -->
<!-- Do not modify the contents of this file by hand. -->
<INVENTORY>
<COMPOSITEHOME_LIST>
</COMPOSITEHOME_LIST>
<VERSION_INFO>
   <SAVED_WITH>10.1.0.2.0</SAVED_WITH>
   <MINIMUM_VER>2.1.0.6.0</MINIMUM_VER>
</VERSION_INFO>
<HOME_LIST>
<HOME NAME="agent11g1" LOC="/opt/oracle/product/agent11g" TYPE="O" IDX="1"/>
<HOME NAME="OraDb11g_home1" LOC="/opt/oracle/product/11.2.0.3" TYPE="O" IDX="2"/>
<HOME NAME="OraDb11g_home2" LOC="/opt/oracle/product/11.2.0.2" TYPE="O" IDX="3"/>
<HOME NAME="Oracle10_102" LOC="/opt/oracle/product/10.2.0.5" TYPE="O" IDX="4"/>
<HOME NAME="Home9_2_0_8" LOC="/opt/oracle/product/9.2.0.8" TYPE="O" IDX="5"/>
</HOME_LIST>
</INVENTORY>
oracle@xsnh10w533s:#
oracle@xsnh10w533s:# cd /opt/oracle/product/9.2.0.8/OPatch
oracle@xsnh10w533s:# ./opatch lsinventory

Oracle Interim Patch Installer version 1.0.0.0.63
Copyright (c) 2009 Oracle Corporation. All Rights Reserved..

Oracle recommends you to use the latest OPatch version
and read the OPatch documentation available in the OPatch/docs
directory for usage. For information about the latest OPatch and
other support-related issues, refer to document ID 293369.1
available on My Oracle Support (https://myoraclesupport.oracle.com)

Oracle Home           : /opt/oracle/product/9.2.0.8
Oracle Home Inventory : /opt/oracle/product/9.2.0.8/inventory
Central Inventory     : /opt/oracle/oraInventory
   from               : /var/opt/oracle/oraInst.loc
OUI location          : /opt/oracle/product/9.2.0.8/oui
OUI shared library    : /opt/oracle/product/9.2.0.8/oui/lib/ia64hpunix/liboraInstaller.so
Java location         : /opt/oracle/product/9.2.0.8/jre/1.4.2/bin/java
Log file location     : /opt/oracle/product/9.2.0.8/.patch_storage/<patch ID>/*.log

Creating log file "/opt/oracle/product/9.2.0.8/.patch_storage/LsInventory__04-17-2014_07-07-33.log"

Result:


  Installed Patch List:
  =====================
  1) Patch  9655027 applied on Thu Jan 19 10:10:56 CET 2012
      Unique Patch ID:  12680934
      [ Bug fixes: 6787081 5933477 6375910 6079599 6647071 8290638 6117049 4115449 6690077 7154115 6639973 6066116 5149865 7592365 7127618 5490859 9117646 9352224 
		   5744161 6079582 5839764 5722472 5605370 6769003 4609147 5089244 5284303 4599763 7154111 4969005 4683638 6521027 6654193 5726053 5754150 5631915
		   5526018 7120509 5929055 6053580 5917099 4970079 2701372 2855117 6826554 5517051 7335157 6057120 6451637 5080775 6120177 6613049 4215910 5965170
		   5116414 8290549 6862814 5514908 6529567 5964709 5188321 4157520 6444045 6646842 5901910 5057695 8836758 6395038 6864197 8534403 6042409 5849054
		   6404861 5703297 6020552 6404447 8525675 6703834 7375695 9119275 9655027 4528014 4334992 5558878 6350567 5901875 7576801 6493035 6319169 4057920
		   5369855 5745084 6153972 5345437 6619946 6453643 6864082 4088156 5372831 5491035 3345222 6954722 5527732 6055396 5631836  ]




OPatch succeeded.
oracle@xsnh10w533s:#

Rerun OPATCH LSINVENTORY. This time it is expected to be successful.


5.	Invoke DBCA from GV desktop. Don’t forget to export DISPLAY=GVPW102.f2.enterprise:0.0

###################To change DB character-Set##################################


http://anuragkumarjoy.blogspot.com/2013/09/how-to-change-character-set-in-oracle.html

Changing Or Choosing the Database Character Set ( NLS_CHARACTERSET ) (Doc ID 225912.1)

Changing the NLS_CHARACTERSET from UTF8 to AL32UTF8 (or from AL32UTF8 to UTF8) can be done by using Note 260192.1 
(https://support.oracle.com/epmos/faces/DocumentDisplay?id=260192.1) Changing the NLS_CHARACTERSET to AL32UTF8 / UTF8 (Unicode) in 8i, 9i, 10g and 11g. .




########################RAC Commands####################################################


Health Check Commands on RAC :

[root@xspl10a982cn01 bin]# ./ocrcheck

[root@xspl10a982cn01 bin]# ./crsctl query css votedisk

[grid@xspl10a982cn01 ~]$ /sbin/acfsutil registry

[grid@xspl10a982cn01 ~]$ /sbin/acfsutil info fs

[grid@xspl10a982cn01 ~]$ srvctl status database -d O1D10405

[grid@xspl10a982cn01 ~]$ srvctl status database -d racdg

[grid@xspl10a982cn01 ~]$ crsctl stat res -t

[grid@xspl10a982cn01 ~]$ crsctl check cluster

[grid@xspl10a982cn01 ~]$ crsctl check cluster -all

[grid@xspl10a982cn01 ~]$ ps -ef | grep crs | grep -v grep

SQL> select GROUP_NUMBER,NAME,STATE,OFFLINE_DISKS from V$ASM_DISKGROUP;

SQL> select GROUP_NUMBER,DISK_NUMBER,MOUNT_STATUS,STATE from v$asm_disk;



VOTING DISK
-----------
          Known as Quorum Disk in 9i. Located on shared storage accessible to all instances. Used to determine
          RAC instance membership. In the event of node failure voting disk is used to determine which instance 
          takes control of cluster to avoid split brain. In 10.2 and above, can be mirrored.

WHAT IS OCR
-----------
          Oracle cluster registry, config information for oracle clusterware/CRS. similar to windows registry.
          located on shared storage. maximum two copies. defines cluster resources including db, instances,asm
          services, nodeapps, vip, gsd, listener

to identify which ocfs packages installed in linux (the package version should match across all nodes)
          $ rpm -qa | grep ocfs

kernel module is required to be an exact match to the running kernel version in order for ocfs2 to operate
          $ uname -r
          The ocfs kernel module must match this version exactly
          $ rpm -q ocfs-`uname -r`

Check to make sure that both the o2cb and ocfs2 services are set to start at boot
          $ chkconfig --list o2cb
          o2cb 0:off 1:off 2:on 3:on 4:on 5:on 6:off
          $ chkconfig --list ocfs2
          ocfs2 0:off 1:off 2:on 3:on 4:on 5:on 6:off

          If the services are not "on" for runlevels 2 through 5, run the following commands
          $ chkconfig o2cb on
          $ chkconfig ocfs2 on

to check ocfs version
          $ cat /proc/fs/ocfs2/version

HOW TO IDENTIFY THE CLUSTER MANAGER IS RUNNING FROM WHICH ORACLE HOME
---------------------------------------------------------------------
          -- customers has more than one oracm installed on different ORACLE_HOMEs and they want to identify
          oracm is running from which ORACLE_HOME. The ps command doesn't show that information. You can use
          the information from /proc on linux.
          $ ps -auxwww |grep oracm (and get the pid of the oracm, for eg the pid is 4070)
          $ ls -l /proc/4070/exe /proc/4070/cwd
          lrwxrwxrwx 1 root root 0 May 5 11:50 /proc/4070/cwd -> /u01/app/oracle/9.2.0/oracm/bin
          lrwxrwxrwx 1 root root 0 May 5 11:50 
          /proc/4070/exe -> /u01/app/oracle/9.2.0/oracm/bin/oracm (in this example, oracm is running from 9.2.0 home)

TO VIEW THE CLUSTER NAME
------------------------
          -- oracle creates a directory with the same name as cluster under the $ORA_CRS_HOME/cdata. You
          can get the cluster name from this directory.

VIEWING OF NODES CONFIGURED IN THE CLUSTER
------------------------------------------
          -- to findout the nodes registered into the cluster, displays node's public, private & virtual name along 
          with their numbers
          $ olsnodes -n -p -i

VIEWING OCR DISK INFORMATION
----------------------------
          -- to view the no. of OCR files configured in the cluster, version of OCR as well as storage space info.
             You can only have 2 OCR files at max
          $ ocrcheck

ADD/REMOVE OCR FILE IN CLUSTER
------------------------------
          -- get the existing OCR file info by running ocrcheck utility
          $ ocrcheck
          Status of Oracle Cluster Registry is as follows :
          Version : 2
          Total space (kbytes) : 262120
          Used space (kbytes) : 3852
          Available space (kbytes) : 258268
          ID : 744414276
          Device/File Name : /u02/ocfs2/ocr/OCRfile_0 <-- OCR
          Device/File integrity check succeeded
          Device/File Name : /u02/ocfs2/ocr/OCRfile_1 <-- OCR Mirror
          Device/File integrity check succeeded
          Cluster registry integrity check succeeded

          $ ocrconfig -replace ocrmirror        <= removes the OCR mirror file or adds OCR mirror if mirror doesn't exist
          $ ocrconfig -replace ocr       <= removes the OCR file

VOTEDISK MAINTENANCE
--------------------
          -- stop CRS on all the nodes in cluster but one.
          $ crsctl stop crs

          -- get the list of existing vote disks
          $ crsctl query css votedisk
          0. 0 /u02/ocfs2/vote/VDFile_0
          1. 0 /u02/ocfs2/vote/VDFile_1
          2. 0 /u02/ocfs2/vote/VDFile_2
          Located 3 voting disk(s).
          
          -- Backup the VoteDIsk file
          $ dd if=/u02/ocfs2/vote/VDFile_0 of=$ORACLE_BASE/bkp/vd/VDFile_0
          
          -- to add extra votedisk into the cluster. if it is a OCFS, then touch the file as oracle.
          on raw devices, initialize the raw devices using "dd" command.
          $ touch /u02/ocfs2/vote/VDFile_3   <= as oracle
          $ crsctl add css votedisk /u02/ocfs2/vote/VDFile_3 <= as root

          -- to delete votedisk
          $ crsctl delete css votedisk /u02/ocfs2/vote/VDFile_3

          -- restore votedisk
          shutdown CRS on all the nodes in the cluster, locate current location of the votedisks.
          restore each of the votedisks using "dd" command from the previous good backup taken using
          the same "dd" command & start CRS on all the nodes.
          $ crsctl stop crs
          $ crsctl query css votedisk
          $ dd if= of=  <= do this for all the votedisks
          $ crsctl start crs

BACKING UP OCR
--------------
          -- oracle performs physical backup of OCR devices every 4 hrs under the default directory $ORA_CRS_HOME/cdata/
          and then it rolls that forward to daily, weekly and monthly backup.
          $ ocrconfig -showbackup

          -- manually backing up the OCR
          $ ocrconfig -manualbackup <= backs up OCR under the default backup directory.

          -- export the contents of OCR using below command (Logical backup)
          $ ocrconfig -export /tmp/ocr_exp.dat -s online
          $ ocrconfig -export /tmp/ocr_exp.dat -s online


RESTORING OCR
-------------
          -- restore OCR from the physical backup. shutdown CRS on all nodes.
          $ ocrconfig -restore
          
          -- perform restore from previous backup (week old)
          $ ocrconfig -restore /u01/app/crs/cdata/test-crs/week.ocr

          -- import the OCR logical backup
          $ ocrconfig -import /tmp/ocr_exp.dat


How do I identify the OCR file location
---------------------------------------
check /var/opt/oracle/ocr.loc or /etc/ocr.loc ( depends upon platform)
or
#ocrcheck



CLUSTER RELATED COMMANDS
------------------------
          $ crsstat, crs_stat -t       - shows HA resource status
          $ ps -ef|grep d.bin          - crsd.bin, evmd.bin & ocssd.bin
          $ crsctl get css disktimeout - disk latencies in sec from node-to-votedisk. Default is 200 (disk I/O)
          $ crsctl get css misscount   - network latencies in sec from node-to-node (interconnect), default is 60 (linux)
                                       and 30 (unix). Network I/O. Missount < Disktimeout
          $ crsctl get css reboottime
          $ crsctl query css votedisk - to view the no. of votedisks configured in the cluster
          $ crsctl check crs          - CSS, CRS, EVM appears healthy
          $ crsctl check cluster      - check status of remote nodes in the cluster
          $ crsctl stop crs           - stop CRS and all other services
          $ crsctl disable crs*       - prevents CRS from starting on reboot (update the file /etc/oracle/scls_scr/<node>/root/crsstart which contains the string “disable”)
          $ crsctl enable crs*     - enable CRS start on reboot (update the file /etc/oracle/scls_scr/<node>/root/crsstart which contains the string “enable”)
          $ crs_stop -all          - stops all registered resources
          $ crs_start -all         - starts all registered resources

DATABASE RELATED COMMANDS
-------------------------
          $ srvctl start instance -d <db_name> -i <inst_name>     - Starts an instance 
          $ srvctl start database -d <db_name>                    - Starts all instances 
          $ srvctl stop database -d <db_name>                     - Stops all instances, closes database 
          $ srvctl stop instance -d <db_name> -i <inst_name>      - Stops an instance 
          $ srvctl start service -d <db_name> -s <service_name>   - Starts a service 
          $ srvctl stop service -d <db_name> -s <service_name>    - Stops a service 
          $ srvctl status service -d <db_name>                    - Checks status of a service 
          $ srvctl status instance -d <db_name> -i <inst_name>    - Checks an individual instance 
          $ srvctl status database -d <db_name>                   - Checks status of all instances 
          $ srvctl start nodeapps -n <node_name>                  - Starts gsd, vip, listener, and ons 
          $ srvctl stop nodeapps -n <node_name>                   - Stops gsd, vip and listener 
          $ srvctl remove asm -n <node_name> [-i <asm_instance>]  - to remove an ASM instance
          $ srvctl enable asm -n <node_name> [-i <asm_instance>]  - to enable an ASM instance
          $ srvctl disable asm -n <node_name> [-i <asm_instance>] - to disable an ASM instance
          $ srvctl start asm -n <node_name> [-i <asm_instance>] [-o start]
          $ srvctl start asm -n <node_name> [-i <asm_instance>] [-o stop]
          $ srvctl start asm -n <node_name> [-i <asm_instance>] [-o status]
          $ srvctl config database/nodeapps/asm/service


[grid@xspl10c301pn01 ~]$ crsctl check cluster -all

STOPPING CRS
------------
          Sun or Linux: 
          /etc/init.d/init.crs disable 
          /etc/init.d/init.crs stop 

          HP-UX or HP Tru64:: 
          /sbin/init.d/init.crs disable 
          /sbin/init.d/init.crs stop 

          IBM AIX: 
          /etc/init.crs disable 
          /etc/init.crs stop


SCAN LISTENER
-------------
          $ srvctl status scan_listener


HOW TO VIEW INTERCONNECTS ?
----------------------------

v$configured_interconnects;
      


#################################Dataguard##########################################################


When you are using Dataguard, there are several scenarios when physical standby can go out of sync with the primary database.

Before doing anything to correct the problem, we need to verify that why standby is not in sync with the primary. In this particular article, we are covering the scenario where a log is missing from the standby but apart from the missing log, all logs are available. 

Verify from v$archived_log that there is a gap in the sequence number. All the logs up to that gap should have APPLIED=YES and all the sequence# after the missing log sequence# are APPLIED=NO. This means that due to the missing log, MRP is not applying the logs on standby but the logs are still being transmitted to the standby and are available.

SQL> SELECT SEQUENCE#, APPLIED FROM V$ARCHIVED_LOG order by SEQUENCE#;

So for example, if the missing log sequence# is 400, then the above query should show that up to sequence#399, all have APPLIED=YES and starting from 401, all are APPLIED=NO.

There are few steps to be performed when the standby is not in sync with the primary because there is a gap of logs on standby.

These steps are:

STEP #1: Take an incremental backup of primary from the SCN where standby is lagging behind and apply on the standby server 

STEP #2: If step#1 is not able to sync up, then re-create the controlfile of standby database from the primary

STEP #3: If after step#2, you still find that logs are not being applied on the standby, check the alert log and you may need to re-register the logs with the standby database.

*******************************************************************************************

STEP#1

1. On STANDBY database query the v$database view and record the current SCN of the standby database:

SQL> SELECT CURRENT_SCN FROM V$DATABASE;

CURRENT_SCN

-----------

1.3945E+10

 

SQL> SELECT to_char(CURRENT_SCN) FROM V$DATABASE;

TO_CHAR(CURRENT_SCN)

----------------------------------------

13945141914

2. Stop Redo Apply on the standby database:

SQL> ALTER DATABASE RECOVER MANAGED STANDBY DATABASE CANCEL;

ALTER DATABASE RECOVER MANAGED STANDBY DATABASE CANCEL

*

ERROR at line 1:

ORA-16136: Managed Standby Recovery not active

If you see the above error, it means Managed Recovery is already off

You can also confirm from the view v$managed_standby to see if the MRP is running or not

SQL> SELECT PROCESS, STATUS FROM V$MANAGED_STANDBY;

3. Connect to the primary database as the RMAN target and create an incremental backup from the current SCN of the standby database that was recorded in step 1:

For example, 

BACKUP as compressed INCREMENTAL FROM SCN 13506166580862 DATABASE FORMAT '/tmp/ForStandby_%U' tag 'FOR STANDBY'

You can choose a location other than /tmp also.

4. Do a recovery of the standby database using the incremental backup of primary taken above:

On the Standby server, without connecting to recovery catalog, catalog the backupset of the incremental backup taken above. Before this, of course you need to copy the backup piece of the incremental backup taken above to a location accessible to standby server.

$ rman nocatalog target /

RMAN> CATALOG BACKUPPIECE '/dump/proddb/inc_bkup/ForStandby_1qjm8jn2_1_1';

Now in the same session, start the recovery

RMAN> RECOVER DATABASE NOREDO;

You should see something like:

Starting recover at 2008-09-17 04:59:57

allocated channel: ORA_DISK_1

channel ORA_DISK_1: sid=309 devtype=DISK

channel ORA_DISK_1: starting incremental datafile backupset restore

channel ORA_DISK_1: specifying datafile(s) to restore from backup set

....

..

..

.

channel ORA_DISK_1: reading from backup piece /dump/proddb/inc_bkup/ForStandby_1qjm8jn2_1_1

channel ORA_DISK_1: restored backup piece 1

piece handle=/dump/proddb/inc_bkup/ForStandby_1qjm8jn2_1_1 tag=FOR STANDBY

channel ORA_DISK_1: restore complete, elapsed time: 01:53:08

Finished recover at 2008-07-25 05:20:3

Delete the backup set from standby:

RMAN> DELETE BACKUP TAG 'FOR STANDBY';

using channel ORA_DISK_1

List of Backup Pieces

BP Key  BS Key  Pc# Cp# Status      Device Type Piece Name

------- ------- --- --- ----------- ----------- ----------

17713   17713   1   1   AVAILABLE   DISK        /dump/proddb/inc_bkup/ForStandby_1qjm8jn2_1_1

Do you really want to delete the above objects (enter YES or NO)? YES

deleted backup piece

backup piece handle=/dump/proddb/inc_bkup/ForStandby_1qjm8jn2_1_1 recid=17713 stamp=660972421

Deleted 1 objects

5. Try to start the managed recovery.

ALTER DATABASE RECOVER MANAGED STANDBY DATABASE USING CURRENT LOGFILE DISCONNECT FROM SESSION;

If you get an error here, you need to go to STEP#2 for bringing standby in sync.

If no error, then using the view v$managed_standby, verify that MRP process is started and has the status APPLYING_LOGS.

6. After this, check whether the logs are being applied on the standby or not:

SQL> SELECT SEQUENCE#, APPLIED FROM V$ARCHIVED_LOG order by SEQUENCE#;

After doing a recovery using the incremental backup, you will not see the sequence#'s which were visible earlier with APPLIED=NO because they have been absorbed as part of the incremental backup and applied on standby during recovery.

The APPLIED column starts showing YES for the logs which are being transmitted now, this means logs are being applied.

Check the status of MRP process in the view v$managed_standby. The status should be APPLYING_LOGS for the duration that available logs are being applied and once all available logs have been applied, the status should be WAITING_FOR_LOGS

7. Another check to verify that primary and standby are in sync. Run the following query on both standby and primary:

SQL> select max(sequence#) from v$log_history.

Output should be same on both databases.

*******************************************************************************************

STEP #2: 

Since Managed recovery failed after applying the incremental backup, we need to recreate the controlfile of standby. The reason for recreating the controlfile is that the state of the database was same because the database_scn was not updated in the control file after applying the incremental backup while the scn for datafiles were updated. Consequently, the standby database was still looking for the old file to apply. 

A good MOSC note for re-creating the controlfile in such a scenario is 734862.1.

Steps to recreate the standby controlfile and start the managed recovery on standby:

1. Take the backup of controlfile from primary

rman target sys/oracle@proddb catalog rman/cat@emrep

backup current controlfile for standby;

2. Copy the controlfile backup to the standby system (or if it is on the common NFS mount, no need to transfer or copy) and restore the controlfile onto the standby database

Shutdown all instances (If standby is RAC) of the standby.

sqlplus / as sysdba

shutdown immediate

exit

Startup nomount, one instance.

sqlplus / as sysdba

startup nomount

exit

Restore the standby control file.

rman nocatalog target /

restore standby controlfile from '/tmp/o1_mf_TAG20070220T151030_.bkp';

exit

3. Startup the standby with the new control file.

sqlplus / as sysdba

shutdown immediate

startup mount

exit

4.  Restart managed recovery in one instance (if standby is RAC) of the standby database:

sqlplus / as sysdba

ALTER DATABASE RECOVER MANAGED STANDBY DATABASE DISCONNECT;

The above statement may succeed without errors but the MRP process will still not start. The reason is that since the controlfile has been restored from the primary, it is looking for datafiles at the same location as are in primary instead of standby. For example, if the primary datafiles are located at '+DATA/proddb_1/DATAFILE' and standby datafiles are at '+DATA/proddb_2/DATAFILE', the new controlfile will show the datafile’s location as '+DATA/proddb_1/DATAFILE'. This can be verified from the query "select name from v$datafile" on the standby instance. We need to rename all the datafiles to reflect the correct location.

There are two ways to rename the datafiles:

1. Without using RMAN

Change the parameter standby_file_management=manual in standby’s parameter file.

ALTER DATABASE RENAME FILE '+DATA/proddb_1/datafile/users.310.620229743' TO '+DATA/proddb_2/datafile/USERS.1216.648429765';

2. Using RMAN

rman nocatalog target /

Catalog the files, the string specified should refer to the diskgroup/filesystem destination of the standby data files.

RMAN> catalog start with '+diskgroup/<dbname>/datafile/';

e.g.:

RMAN> catalog start with '+DATA/proddb_2/datafile/';

This will give the user a list of files and ask if they should all be cataloged. The user should review and say YES if all the datafiles are properly listed. 

Once that is done, then commit the changes to the controlfile

RMAN> switch database to copy;

Now start the managed recovery as:

ALTER DATABASE RECOVER MANAGED STANDBY DATABASE DISCONNECT

and check for processes in the view v$managed_standby.  MRP process should be there. It will also start applying all the archived logs that were missing since last applied log.  This process might take hours.

5. Another check to verify that primary and standby are in sync:

Run the following query on both standby and primary after all logs in v$archived_log show APPLIED=YES:

SQL> select max(sequence#) from v$log_history.

Output should be same on both databases.

*****************************************************************************************

STEP #3

After recreating the controlfile, you still find that logs are being transmitted but not being applied on the standby. Check the alert log of standby. For example, see if you find something similar to below snippet:

Fetching gap sequence in thread 1, gap sequence 74069-74095

Wed Sep 17 06:45:47 2008

RFS[1]: Archived Log: '+DATA/ipwp_sac1/archivelog/2008_09_17/thread_1_seq_74093.259.665649929'

Wed Sep 17 06:45:55 2008

Fetching gap sequence in thread 1, gap sequence 74069-74092

Wed Sep 17 06:45:57 2008

RFS[1]: Archived Log: '+DATA/proddb_2/archivelog/2008_09_17/thread_1_seq_74094.258.665649947'

Wed Sep 17 06:46:16 2008

RFS[1]: Archived Log: '+DATA/proddb_2/archivelog/2008_09_17/thread_1_seq_74095.256.665649957'

Wed Sep 17 06:46:26 2008

FAL[client]: Failed to request gap sequence

 GAP - thread 1 sequence 74069-74092

The contents of alert log shows that logs sequence# from 74069 to 74092 may have been transmitted but not applied. The view v$archived_log shows the sequence# starting from 74093 and APPLIED=NO.

So this situation means that logs up to 74068 were applied as part of the incremental backup and from 74069 to 74093 have been transferred to standby server but they must have failed to register with standby database. Try the following steps: 

Locate the log sequence# shown in alert log (for example 74069 to 74092). For example, +DATA/proddb_2/archivelog/2008_09_17/thread_1_seq_74069.995.665630861
Register all these archived logs with the standby database.
alter database register logfile '+DATA/proddb_2/archivelog/2008_09_17/thread_1_seq_74069.995.665630861';

alter database register logfile '+DATA/proddb_2/archivelog/2008_09_17/thread_1_seq_74070.998.665631405';

alter database register logfile '+DATA/proddb_2/archivelog/2008_09_17/thread_1_seq_74071.792.665633755';

alter database register logfile '+DATA/proddb_2/archivelog/2008_09_17/thread_1_seq_74072.263.665633713';

……..

….and so on till the last one.

Now check the view v$archived_log and finally should see the logs being applied. The status of MRP should change from ARCHIVE_LOG_GAP to APPLYING_LOGS and eventually WAITING_FOR_LOGS.

####################################PROXY USER##############################################
If you need to login as user APPUSER (in order to change jobs, create or drop private database links, recompile views etc.) and you don't know the users password, you can do so as proxy user. It works from oracle 10g onwards.

Assuming user "temp_dba" has DBA privileges and his password is "manager" try this:
1. connect temp_dba/manager@tnsalias
2. issue "alter user APPUSER grant connect through temp_dba;" 
3. now connect as IMPACT with password of user temp_dba: 
  "connect temp_dba[APPUSER]/manager@tnsalias" (important: enclose the target user name in brackets "[" and "]"!!)
   This connect method works at least using SQL*Plus.
4. verify that you are connected as user APPUSER: "show user;"
5. now do the maintenance tasks as user APPUSER.
6. When you are done, connect as temp_dba or any user with DBA privs and revoke the proxy user privlege from APPUSER: 
   "alter user APPUSER revoke connect through temp_dba;"

Here is a working example with user SCOTT on my laptop database:
-------------------------------------------------------------------
SQL> connect temp_dba/manager
Connected.

SQL> alter user scott grant connect through temp_dba;

User altered.

SQL> connect temp_dba[scott]/manager
Connected.
SQL> select * from whoami; 

USER                           DATABASE  INSTANCE         MACHINE      
------------------------------ --------- ---------------- -------------
SCOTT                          ORA102    ora102           VMXPDB10G

SQL> connect temp_dba/manager

SQL> alter user scott revoke connect through temp_dba;

User altered.
-----------------           End of example     -------------------------

This method is much better than temporarily resetting the users password and recovering the unknown password afterwards (restoring the password hash recorded prior the password reset) 


################IMPORT/EXPORT####################################################################################


To check import details :

col USERNAME for a10
col SOFAR for 9999999
col MESSAGE for a100
col OPNAME for a20
col TARGET_DESC for a5
select username,opname,target_desc,sofar,totalwork,message from V$SESSION_LONGOPS;

How to delete/remove non executing datapump jobs?
-------------------------------------------------
1.Identify which jobs are in NOT RUNNING status:

SET lines 200
SELECT owner_name, job_name, operation, job_mode,
state, attached_sessions
FROM dba_datapump_jobs
ORDER BY 1,2;

2. Identify the master tables which are created for these jobs:

SELECT o.status, o.object_id, o.object_type,
o.owner||’.’||object_name “OWNER.OBJECT”
FROM dba_objects o, dba_datapump_jobs j
WHERE o.owner=j.owner_name AND o.object_name=j.job_name
AND j.job_name NOT LIKE ‘BIN$%’ ORDER BY 4,2;

3. Drop these master tables in order to cleanup the jobs:

SQL> DROP TABLE SYSTEM.SYS_EXPORT_FULL_01;
SQL> DROP TABLE SCOTT.SYS_EXPORT_TABLE_02 ;
SQL> DROP TABLE SCOTT.EXPDP_20051121;


4. Re-run the query which is used in step 1 to check if still any jobs are showing up.


exp " '/ as sysdba' " dumpfile=RVRRCF.dmp logfile=RVRRCF.log directory=INVTER_DIR_DATATEMP SCHEMAS=RVRRCF CONSISTENT=Y 

nohup exp " '/ as sysdba' " file=/export/home/HPSUSRP.dmp log=HPSUSRP.log  owner=HPSUSRP &

nohup expdp " '/ as sysdba' " dumpfile=HPSUSRP.dmp logfile=HPSUSRP.log directory=DDUMP SCHEMAS='HPSUSRP'  &

nohup expdp " '/ as sysdba' " dumpfile=CRQ000000131033_SPM.dmp logfile=CRQ000000131033_SPM.log directory=DATAPUMP SCHEMAS='GEN$SPM' &

nohup impdp " '/ as sysdba' " dumpfile=ERECA.dmp logfile=ERECA_import.log directory=DATAPUMP REMAP_SCHEMA='GEN$ERECA':'GEN$ERECAINT' REMAP_TABLESPACE=ERECA:ERECAINT  &


select object_type,count(1) from dba_objects where owner='PHXLST' group by object_type order by object_type;

select sum(bytes/1024/1024/1024) from dba_segments where owner='ITSM_DWH';

FLASHBACK_TIME = "TO_TIMESTAMP (TO_CHAR (SYSDATE, ' YYYY-MM-DD HH24:MI:SS'),'YYYY-MM-DD HH24:MI:SS')"

Import Parameters:
USERID="/ as sysdba"
FILE=exp_O2D11798_schema.dmp
LOG=imp_O2D11798-O4D11798_schema.log
FROMUSER=GEFF_ADMIN,GEFF_WEB,GEFF_SAP,GEFF_READ,GEFF_WRITE,GEFFI_ADMIN,GEFFI_WEB,GEFFI_SAP,GEFFI_READ,GEFFI_WRITE
TOUSER=GEFF_ADMIN,GEFF_WEB,GEFF_SAP,GEFF_READ,GEFF_WRITE,GEFFI_ADMIN,GEFFI_WEB,GEFFI_SAP,GEFFI_READ,GEFFI_WRITE
RESUMABLE=Y
RESUMABLE_TIMEOUT=5200

exclude=table:"IN('T_DEV_FICHIER')" 



######################GET DDL####################################

set head off
set pages 0
set long 9999999

select DBMS_METADATA.GET_DDL('PACKAGE_BODY','COLLECTSTATS','MYSCHEMA') from DUAL;


select DBMS_METADATA.GET_DDL('PACKAGE_BODY','TINFOSYNCH','ALICE') from DUAL;




##############################DYNAMIC SQL's#######################################################


select 'ALTER TABLE '||TABLE_NAME||' ENABLE CONSTRAINTS '||CONSTRAINT_NAME||';' from user_constraints where owner='IMPACT' AND status='DISABLED';

select 'truncate table ' ||  object_name || ';' from dba_objects where owner='IMPACT' and object_type='TABLE';

select 'alter database datafile "'||file_name||'" AUTOEXTEND OFF;' from dba_data_files

Select decode( object_type, 'PACKAGE BODY', 'ALTER PACKAGE ' || OBJECT_NAME || ' COMPILE BODY;','ALTER ' || OBJECT_TYPE || ' ' || OBJECT_NAME || ' compile;' )
from dba_objects
where status = 'INVALID' and OWNER='SPECTRA_FS_BI'
order by object_type;

select 'cp '||file_name||' to '|| '/SETA2/oracle/data' from dba_data_files;

select 'ALTER DATABASE RENAME FILE '||file_name||' '||'TO'|| ' /SETA/oracle/ex3510/tstest/data/' from dba_data_files;

select 'ALTER DATABASE RENAME FILE '||'file_id'||' '||'TO'|| ' /SETA/oracle/ex3510/tstest/data/(select file_id from v$datafile)' from v$datafiles;

select 'alter database rename file ' ||""|| file_name || "" || ' to '|| ""||
'/SETA/oracle/ex3510/tstest/data/' || substr(file_name, instr(file_name, '/', -1)) ||"" || ';'
from dba_data_files

select 'alter user '||username||' identified by values '||REGEXP_SUBSTR(DBMS_METADATA.get_ddl ('USER',USERNAME), '''[^'']+''')||';' 

alter user MYTEST identified by values 'S:A4CE024B548C4C11C886A735F0D00314C1050C7A9C4FC492585BA2BC8520;D9402F621C938AC1'; 

select REGEXP_SUBSTR(DBMS_METADATA.get_ddl ('USER','MYUSER'), '''[^'']+''') PASSWD from dual;

select 'drop '||object_type||' '||owner||'.'||object_name||';' from dba_objects where owner='PMAG';

select count(*) object_name from dba_objects where owner='PMAG';

select 'grant READ,WRITE on '||object_type||'.'||object_name||' to '||'DE005351'||';'|| from dba_objects where owner='ADMBAR';

select 'grant READ,WRITE on '||owner||'.'||object_name||' to '||'DE005351'||';' from all_objects where owner in ('TARGET_INTF_ADM','DDW_INTF','CHEMBIO_INTF','BAR_INTF','GLUE_INTF') and  object_type in ('VIEW','TABLE');

select 'grant SELECT on '||owner||'.'||object_name||' to '||'ABC8BKY'||';' from dba_objects where owner='DPL_DEAL' and  object_type='TABLE';


select 'grant SELECT,UPDATE,DELETE on '||owner||'.'||object_name||' to '||'ABC8BKY'||';' from dba_objects where owner='DPL_DEAL' and  object_type='TABLE';


select 'DROP table ' ||  object_name || ';' from dba_objects where owner='DEVDWH7' and object_type='TABLE';


SQL> CREATE USER DE005351 IDENTIFIED BY Welcome DEFAULT TABLESPACE USERS TEMPORARY TABLESPACE TEMP;

User created.

SQL>  CREATE USER DE017889 IDENTIFIED BY Welcome DEFAULT TABLESPACE USERS TEMPORARY TABLESPACE TEMP;



with CHECK_RECLAIMABLE_SPACE as
(
-- Purpose:         CHECK FOR RECLAIMABLE FREABLE SPACE AT SEGMENT LEVEL
-- Oracle Versions: works at least from oracle 9.2 onwards
-- 13-SEP-2012 Norbert Keuler, Logica 
--
-- Limitations:
-- 1. This script relys on optimizer statistics for tables. Depending on how
-- statistics are created, the amount of reclamable space (output of column 
-- FREEABLE_MB) may be over- or underestimated.
-- 2. This script checks table segments only. No INDEXES and LOBS are taken into account.
-- If there are lots of indexes and lobs, the reclaimable space might be underestimated,
-- depending on filter criteria given in the where clause.
-- 
-- A precise value to determine reclaimable space requires the segment high water marks 
-- to be known. In this script however, I refer to an estimate of the logical space used 
-- by formula: 
-- (average space per row) * (number of rows).
-- This amount is a lower limit estimate of the required space after reorganizing the data 
-- (should be increased about 10 or 20 percent to allow for overhead such as block header).
-- Using this value instead of the high water mark targets at the space that COULD BE
-- RELEASED after reorganzing. The high water mark tells how much space can be released
-- immediately.
--
-- According to My Oracle Support Note [ID 220450.1] "Is the High Water Mark Reset When 
-- Moving a Table to Another Tablespace or When Import?" the high water mark of a table
-- can be determined from column BLOCKS in DBA_TABLES. 
-- I feel this in not always true, depending on Oracle Version and method of statistics
-- generation (analyze table, dbms_stats.gather_table_stats). However, a relyable way
-- to determine the number of blocks above the high water mark is procedure
-- DBMS_SPACE.UNUSED_BLOCKS.
--
-- Some columns explained:
-- last_analyzed       : statistics creation date
-- sample_size_pct     : ratio of sampled rows to total number of rows
-- num_rows            : number of rows in the table 
-- the three statistic related columns above give a clue whether statistics are 
-- relyable or not.
--
-- used_row_space_mb   : logically space used (mega bytes)
-- used_blocks_space_mb: high water mark position in mb (provided Support Note 220450.1 is correct, have some doubts)
-- allocated_mb        : phyically allocated space (mega bytes)   
-- min_size_mb         : minimum space allocated physically (mega byte) due to 
--                       INITAL storage parameter. 
--                       CAUTION: space cannot be released below this value
--                       even it the high water mark is lower. 
--                       Use ALTER TABLE <tname> MOVE STORAGE (INITIAL <new size>) to change.
-- freeable_mb         : free space above the high water mark (mega bytes)
-- pct_freeable        : ratio freeable space above high water mark to total space allocated.
--
select t.owner
     , t.table_name
     , s.tablespace_name
     , t.last_analyzed
     , round(100 * decode (t.num_rows, 0, 1, t.sample_size/t.num_rows), 1) sample_size_pct 
     , t.num_rows
     , round( t.avg_row_len * t.num_rows/power(2, 20), 1)                  used_row_space_mb
     , round( t.blocks * ((s.bytes/s.blocks) / power(2, 20)), 1)           used_blocks_space_mb
     , round( s.bytes/power(2,20), 1)                                      allocated_mb
     , round( t.initial_extent/power(2, 20), 1)                            min_size_mb
     , round( (s.blocks - t.blocks) * (s.bytes/s.blocks)/power(2,20), 1)   freeable_mb
-- next columns commented out - for troubleshooting only
--     , s.blocks blocks_alloc  --  allocated blocks
--     , t.blocks blocks_used   --  high water mark acording Support Note 220450.1 
--     , s.blocks - t.blocks blocks_freeable  -- blocks above high watermark,
--     , t.empty_blocks
     , round((1-t.blocks/s.blocks)*100,1)                                  pct_freeable
from dba_segments s inner join dba_tables t 
  on ( s.owner = t.owner 
  and  s.segment_name = t.table_name
  and  s.segment_type = 'TABLE' ) 
-- optional filter criteria  
where t.owner like 'IMPACT%'
-- and table_name = 'KALKSAWERT' 
-- check for segments where a reorg cannot releasse much space due to high initial_extent table parameter
  and t.avg_row_len * t.num_rows  < t.initial_extent 
  and t.blocks * ((s.bytes/s.blocks) / power(2, 20)) >= 10  -- used_blocks_space > this number of MB
  )
-- use query in next line to get details at table level:  
select * from check_reclaimable_space order by owner, table_name 
-- use query in next line to get summary information:
-- select tablespace_name, count(*), sum(freeable_mb ) freeable_mb from from check_reclaimable_space group by tablespace_name
;


Simplified One :
---------------
select t.owner
     , t.table_name
     , s.tablespace_name
     , round( t.avg_row_len * t.num_rows/power(2, 20), 1)                  used_row_space_mb
     , round( t.blocks * ((s.bytes/s.blocks) / power(2, 20)), 1)           used_blocks_space_mb
     , round( s.bytes/power(2,20), 1)                                      allocated_mb
     , round( t.initial_extent/power(2, 20), 1)                            min_size_mb
     , round( (s.blocks - t.blocks) * (s.bytes/s.blocks)/power(2,20), 1)   freeable_mb
     , round((1-t.blocks/s.blocks)*100,1)                                  pct_freeable
from dba_segments s inner join dba_tables t 
  on ( s.owner = t.owner 
  and  s.segment_name = t.table_name
  and  s.segment_type = 'TABLE' ) 


##############################CPU Patching##############################

select action||' '||COMMENTS||' '||ACTION_TIME cpu_apply_history from dba_registry_history where comments like 'PSU%' order by 1;





######################################GG Commands######################################################

To check the lag :

select CAPTURE_NAME,86400*(AVAILABLE_MESSAGE_CREATE_TIME - CAPTURE_MESSAGE_CREATE_TIME)latency_in_seconds from gv$GOLDENGATE_CAPTURE;







============
Thank You,

Avinash Singh
Oracle DBA
13th Dec 2018